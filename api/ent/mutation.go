// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/Wanted-Linx/linx-backend/api/ent/club"
	"github.com/Wanted-Linx/linx-backend/api/ent/clubmember"
	"github.com/Wanted-Linx/linx-backend/api/ent/company"
	"github.com/Wanted-Linx/linx-backend/api/ent/predicate"
	"github.com/Wanted-Linx/linx-backend/api/ent/project"
	"github.com/Wanted-Linx/linx-backend/api/ent/projectclub"
	"github.com/Wanted-Linx/linx-backend/api/ent/projectlog"
	"github.com/Wanted-Linx/linx-backend/api/ent/projectlogfeedback"
	"github.com/Wanted-Linx/linx-backend/api/ent/projectlogparticipant"
	"github.com/Wanted-Linx/linx-backend/api/ent/student"
	"github.com/Wanted-Linx/linx-backend/api/ent/tasktype"
	"github.com/Wanted-Linx/linx-backend/api/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClub                  = "Club"
	TypeClubMember            = "ClubMember"
	TypeCompany               = "Company"
	TypeProject               = "Project"
	TypeProjectClub           = "ProjectClub"
	TypeProjectLog            = "ProjectLog"
	TypeProjectLogFeedback    = "ProjectLogFeedback"
	TypeProjectLogParticipant = "ProjectLogParticipant"
	TypeStudent               = "Student"
	TypeTaskType              = "TaskType"
	TypeUser                  = "User"
)

// ClubMutation represents an operation that mutates the Club nodes in the graph.
type ClubMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	organization        *string
	description         *string
	profile_image       *string
	profile_link        *string
	created_at          *time.Time
	clearedFields       map[string]struct{}
	leader              *int
	clearedleader       bool
	club_member         map[int]struct{}
	removedclub_member  map[int]struct{}
	clearedclub_member  bool
	project             map[int]struct{}
	removedproject      map[int]struct{}
	clearedproject      bool
	project_club        map[int]struct{}
	removedproject_club map[int]struct{}
	clearedproject_club bool
	task_type           map[int]struct{}
	removedtask_type    map[int]struct{}
	clearedtask_type    bool
	done                bool
	oldValue            func(context.Context) (*Club, error)
	predicates          []predicate.Club
}

var _ ent.Mutation = (*ClubMutation)(nil)

// clubOption allows management of the mutation configuration using functional options.
type clubOption func(*ClubMutation)

// newClubMutation creates new mutation for the Club entity.
func newClubMutation(c config, op Op, opts ...clubOption) *ClubMutation {
	m := &ClubMutation{
		config:        c,
		op:            op,
		typ:           TypeClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubID sets the ID field of the mutation.
func withClubID(id int) clubOption {
	return func(m *ClubMutation) {
		var (
			err   error
			once  sync.Once
			value *Club
		)
		m.oldValue = func(ctx context.Context) (*Club, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Club.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClub sets the old Club of the mutation.
func withClub(node *Club) clubOption {
	return func(m *ClubMutation) {
		m.oldValue = func(context.Context) (*Club, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ClubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClubMutation) ResetName() {
	m.name = nil
}

// SetOrganization sets the "organization" field.
func (m *ClubMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *ClubMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *ClubMutation) ResetOrganization() {
	m.organization = nil
}

// SetDescription sets the "description" field.
func (m *ClubMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClubMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ClubMutation) ResetDescription() {
	m.description = nil
}

// SetProfileImage sets the "profile_image" field.
func (m *ClubMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *ClubMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *ClubMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[club.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *ClubMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[club.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *ClubMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, club.FieldProfileImage)
}

// SetProfileLink sets the "profile_link" field.
func (m *ClubMutation) SetProfileLink(s string) {
	m.profile_link = &s
}

// ProfileLink returns the value of the "profile_link" field in the mutation.
func (m *ClubMutation) ProfileLink() (r string, exists bool) {
	v := m.profile_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileLink returns the old "profile_link" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldProfileLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileLink: %w", err)
	}
	return oldValue.ProfileLink, nil
}

// ClearProfileLink clears the value of the "profile_link" field.
func (m *ClubMutation) ClearProfileLink() {
	m.profile_link = nil
	m.clearedFields[club.FieldProfileLink] = struct{}{}
}

// ProfileLinkCleared returns if the "profile_link" field was cleared in this mutation.
func (m *ClubMutation) ProfileLinkCleared() bool {
	_, ok := m.clearedFields[club.FieldProfileLink]
	return ok
}

// ResetProfileLink resets all changes to the "profile_link" field.
func (m *ClubMutation) ResetProfileLink() {
	m.profile_link = nil
	delete(m.clearedFields, club.FieldProfileLink)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClubMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClubMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClubMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLeaderID sets the "leader" edge to the Student entity by id.
func (m *ClubMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the Student entity.
func (m *ClubMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the Student entity was cleared.
func (m *ClubMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *ClubMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *ClubMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *ClubMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *ClubMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *ClubMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *ClubMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *ClubMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *ClubMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *ClubMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// AddProjectIDs adds the "project" edge to the Project entity by ids.
func (m *ClubMutation) AddProjectIDs(ids ...int) {
	if m.project == nil {
		m.project = make(map[int]struct{})
	}
	for i := range ids {
		m.project[ids[i]] = struct{}{}
	}
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ClubMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ClubMutation) ProjectCleared() bool {
	return m.clearedproject
}

// RemoveProjectIDs removes the "project" edge to the Project entity by IDs.
func (m *ClubMutation) RemoveProjectIDs(ids ...int) {
	if m.removedproject == nil {
		m.removedproject = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project, ids[i])
		m.removedproject[ids[i]] = struct{}{}
	}
}

// RemovedProject returns the removed IDs of the "project" edge to the Project entity.
func (m *ClubMutation) RemovedProjectIDs() (ids []int) {
	for id := range m.removedproject {
		ids = append(ids, id)
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
func (m *ClubMutation) ProjectIDs() (ids []int) {
	for id := range m.project {
		ids = append(ids, id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ClubMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
	m.removedproject = nil
}

// AddProjectClubIDs adds the "project_club" edge to the ProjectClub entity by ids.
func (m *ClubMutation) AddProjectClubIDs(ids ...int) {
	if m.project_club == nil {
		m.project_club = make(map[int]struct{})
	}
	for i := range ids {
		m.project_club[ids[i]] = struct{}{}
	}
}

// ClearProjectClub clears the "project_club" edge to the ProjectClub entity.
func (m *ClubMutation) ClearProjectClub() {
	m.clearedproject_club = true
}

// ProjectClubCleared reports if the "project_club" edge to the ProjectClub entity was cleared.
func (m *ClubMutation) ProjectClubCleared() bool {
	return m.clearedproject_club
}

// RemoveProjectClubIDs removes the "project_club" edge to the ProjectClub entity by IDs.
func (m *ClubMutation) RemoveProjectClubIDs(ids ...int) {
	if m.removedproject_club == nil {
		m.removedproject_club = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_club, ids[i])
		m.removedproject_club[ids[i]] = struct{}{}
	}
}

// RemovedProjectClub returns the removed IDs of the "project_club" edge to the ProjectClub entity.
func (m *ClubMutation) RemovedProjectClubIDs() (ids []int) {
	for id := range m.removedproject_club {
		ids = append(ids, id)
	}
	return
}

// ProjectClubIDs returns the "project_club" edge IDs in the mutation.
func (m *ClubMutation) ProjectClubIDs() (ids []int) {
	for id := range m.project_club {
		ids = append(ids, id)
	}
	return
}

// ResetProjectClub resets all changes to the "project_club" edge.
func (m *ClubMutation) ResetProjectClub() {
	m.project_club = nil
	m.clearedproject_club = false
	m.removedproject_club = nil
}

// AddTaskTypeIDs adds the "task_type" edge to the TaskType entity by ids.
func (m *ClubMutation) AddTaskTypeIDs(ids ...int) {
	if m.task_type == nil {
		m.task_type = make(map[int]struct{})
	}
	for i := range ids {
		m.task_type[ids[i]] = struct{}{}
	}
}

// ClearTaskType clears the "task_type" edge to the TaskType entity.
func (m *ClubMutation) ClearTaskType() {
	m.clearedtask_type = true
}

// TaskTypeCleared reports if the "task_type" edge to the TaskType entity was cleared.
func (m *ClubMutation) TaskTypeCleared() bool {
	return m.clearedtask_type
}

// RemoveTaskTypeIDs removes the "task_type" edge to the TaskType entity by IDs.
func (m *ClubMutation) RemoveTaskTypeIDs(ids ...int) {
	if m.removedtask_type == nil {
		m.removedtask_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_type, ids[i])
		m.removedtask_type[ids[i]] = struct{}{}
	}
}

// RemovedTaskType returns the removed IDs of the "task_type" edge to the TaskType entity.
func (m *ClubMutation) RemovedTaskTypeIDs() (ids []int) {
	for id := range m.removedtask_type {
		ids = append(ids, id)
	}
	return
}

// TaskTypeIDs returns the "task_type" edge IDs in the mutation.
func (m *ClubMutation) TaskTypeIDs() (ids []int) {
	for id := range m.task_type {
		ids = append(ids, id)
	}
	return
}

// ResetTaskType resets all changes to the "task_type" edge.
func (m *ClubMutation) ResetTaskType() {
	m.task_type = nil
	m.clearedtask_type = false
	m.removedtask_type = nil
}

// Where appends a list predicates to the ClubMutation builder.
func (m *ClubMutation) Where(ps ...predicate.Club) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClubMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Club).
func (m *ClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, club.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, club.FieldOrganization)
	}
	if m.description != nil {
		fields = append(fields, club.FieldDescription)
	}
	if m.profile_image != nil {
		fields = append(fields, club.FieldProfileImage)
	}
	if m.profile_link != nil {
		fields = append(fields, club.FieldProfileLink)
	}
	if m.created_at != nil {
		fields = append(fields, club.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case club.FieldName:
		return m.Name()
	case club.FieldOrganization:
		return m.Organization()
	case club.FieldDescription:
		return m.Description()
	case club.FieldProfileImage:
		return m.ProfileImage()
	case club.FieldProfileLink:
		return m.ProfileLink()
	case club.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case club.FieldName:
		return m.OldName(ctx)
	case club.FieldOrganization:
		return m.OldOrganization(ctx)
	case club.FieldDescription:
		return m.OldDescription(ctx)
	case club.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case club.FieldProfileLink:
		return m.OldProfileLink(ctx)
	case club.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Club field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case club.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case club.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case club.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case club.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case club.FieldProfileLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileLink(v)
		return nil
	case club.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Club numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(club.FieldProfileImage) {
		fields = append(fields, club.FieldProfileImage)
	}
	if m.FieldCleared(club.FieldProfileLink) {
		fields = append(fields, club.FieldProfileLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMutation) ClearField(name string) error {
	switch name {
	case club.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	case club.FieldProfileLink:
		m.ClearProfileLink()
		return nil
	}
	return fmt.Errorf("unknown Club nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMutation) ResetField(name string) error {
	switch name {
	case club.FieldName:
		m.ResetName()
		return nil
	case club.FieldOrganization:
		m.ResetOrganization()
		return nil
	case club.FieldDescription:
		m.ResetDescription()
		return nil
	case club.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case club.FieldProfileLink:
		m.ResetProfileLink()
		return nil
	case club.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.leader != nil {
		edges = append(edges, club.EdgeLeader)
	}
	if m.club_member != nil {
		edges = append(edges, club.EdgeClubMember)
	}
	if m.project != nil {
		edges = append(edges, club.EdgeProject)
	}
	if m.project_club != nil {
		edges = append(edges, club.EdgeProjectClub)
	}
	if m.task_type != nil {
		edges = append(edges, club.EdgeTaskType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeProject:
		ids := make([]ent.Value, 0, len(m.project))
		for id := range m.project {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeProjectClub:
		ids := make([]ent.Value, 0, len(m.project_club))
		for id := range m.project_club {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.task_type))
		for id := range m.task_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedclub_member != nil {
		edges = append(edges, club.EdgeClubMember)
	}
	if m.removedproject != nil {
		edges = append(edges, club.EdgeProject)
	}
	if m.removedproject_club != nil {
		edges = append(edges, club.EdgeProjectClub)
	}
	if m.removedtask_type != nil {
		edges = append(edges, club.EdgeTaskType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeProject:
		ids := make([]ent.Value, 0, len(m.removedproject))
		for id := range m.removedproject {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeProjectClub:
		ids := make([]ent.Value, 0, len(m.removedproject_club))
		for id := range m.removedproject_club {
			ids = append(ids, id)
		}
		return ids
	case club.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.removedtask_type))
		for id := range m.removedtask_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedleader {
		edges = append(edges, club.EdgeLeader)
	}
	if m.clearedclub_member {
		edges = append(edges, club.EdgeClubMember)
	}
	if m.clearedproject {
		edges = append(edges, club.EdgeProject)
	}
	if m.clearedproject_club {
		edges = append(edges, club.EdgeProjectClub)
	}
	if m.clearedtask_type {
		edges = append(edges, club.EdgeTaskType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMutation) EdgeCleared(name string) bool {
	switch name {
	case club.EdgeLeader:
		return m.clearedleader
	case club.EdgeClubMember:
		return m.clearedclub_member
	case club.EdgeProject:
		return m.clearedproject
	case club.EdgeProjectClub:
		return m.clearedproject_club
	case club.EdgeTaskType:
		return m.clearedtask_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMutation) ClearEdge(name string) error {
	switch name {
	case club.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Club unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMutation) ResetEdge(name string) error {
	switch name {
	case club.EdgeLeader:
		m.ResetLeader()
		return nil
	case club.EdgeClubMember:
		m.ResetClubMember()
		return nil
	case club.EdgeProject:
		m.ResetProject()
		return nil
	case club.EdgeProjectClub:
		m.ResetProjectClub()
		return nil
	case club.EdgeTaskType:
		m.ResetTaskType()
		return nil
	}
	return fmt.Errorf("unknown Club edge %s", name)
}

// ClubMemberMutation represents an operation that mutates the ClubMember nodes in the graph.
type ClubMemberMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	club           *int
	clearedclub    bool
	done           bool
	oldValue       func(context.Context) (*ClubMember, error)
	predicates     []predicate.ClubMember
}

var _ ent.Mutation = (*ClubMemberMutation)(nil)

// clubmemberOption allows management of the mutation configuration using functional options.
type clubmemberOption func(*ClubMemberMutation)

// newClubMemberMutation creates new mutation for the ClubMember entity.
func newClubMemberMutation(c config, op Op, opts ...clubmemberOption) *ClubMemberMutation {
	m := &ClubMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeClubMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubMemberID sets the ID field of the mutation.
func withClubMemberID(id int) clubmemberOption {
	return func(m *ClubMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubMember
		)
		m.oldValue = func(ctx context.Context) (*ClubMember, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubMember sets the old ClubMember of the mutation.
func withClubMember(node *ClubMember) clubmemberOption {
	return func(m *ClubMemberMutation) {
		m.oldValue = func(context.Context) (*ClubMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClubID sets the "club_id" field.
func (m *ClubMemberMutation) SetClubID(i int) {
	m.club = &i
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *ClubMemberMutation) ClubID() (r int, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the ClubMember entity.
// If the ClubMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMemberMutation) OldClubID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *ClubMemberMutation) ResetClubID() {
	m.club = nil
}

// SetStudentID sets the "student_id" field.
func (m *ClubMemberMutation) SetStudentID(i int) {
	m.student = &i
}

// StudentID returns the value of the "student_id" field in the mutation.
func (m *ClubMemberMutation) StudentID() (r int, exists bool) {
	v := m.student
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentID returns the old "student_id" field's value of the ClubMember entity.
// If the ClubMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMemberMutation) OldStudentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentID: %w", err)
	}
	return oldValue.StudentID, nil
}

// ResetStudentID resets all changes to the "student_id" field.
func (m *ClubMemberMutation) ResetStudentID() {
	m.student = nil
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ClubMemberMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ClubMemberMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ClubMemberMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClubMemberMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// ClearClub clears the "club" edge to the Club entity.
func (m *ClubMemberMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *ClubMemberMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ClubMemberMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *ClubMemberMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// Where appends a list predicates to the ClubMemberMutation builder.
func (m *ClubMemberMutation) Where(ps ...predicate.ClubMember) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClubMemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClubMember).
func (m *ClubMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMemberMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.club != nil {
		fields = append(fields, clubmember.FieldClubID)
	}
	if m.student != nil {
		fields = append(fields, clubmember.FieldStudentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubmember.FieldClubID:
		return m.ClubID()
	case clubmember.FieldStudentID:
		return m.StudentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubmember.FieldClubID:
		return m.OldClubID(ctx)
	case clubmember.FieldStudentID:
		return m.OldStudentID(ctx)
	}
	return nil, fmt.Errorf("unknown ClubMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubmember.FieldClubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	case clubmember.FieldStudentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentID(v)
		return nil
	}
	return fmt.Errorf("unknown ClubMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClubMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMemberMutation) ResetField(name string) error {
	switch name {
	case clubmember.FieldClubID:
		m.ResetClubID()
		return nil
	case clubmember.FieldStudentID:
		m.ResetStudentID()
		return nil
	}
	return fmt.Errorf("unknown ClubMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, clubmember.EdgeStudent)
	}
	if m.club != nil {
		edges = append(edges, clubmember.EdgeClub)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubmember.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case clubmember.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, clubmember.EdgeStudent)
	}
	if m.clearedclub {
		edges = append(edges, clubmember.EdgeClub)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case clubmember.EdgeStudent:
		return m.clearedstudent
	case clubmember.EdgeClub:
		return m.clearedclub
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMemberMutation) ClearEdge(name string) error {
	switch name {
	case clubmember.EdgeStudent:
		m.ClearStudent()
		return nil
	case clubmember.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown ClubMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMemberMutation) ResetEdge(name string) error {
	switch name {
	case clubmember.EdgeStudent:
		m.ResetStudent()
		return nil
	case clubmember.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown ClubMember edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op               Op
	typ              string
	id               *int
	name             *string
	business_number  *string
	address          *string
	description      *string
	profile_image    *string
	hompage          *string
	clearedFields    map[string]struct{}
	user             *int
	cleareduser      bool
	project          map[int]struct{}
	removedproject   map[int]struct{}
	clearedproject   bool
	task_type        map[int]struct{}
	removedtask_type map[int]struct{}
	clearedtask_type bool
	done             bool
	oldValue         func(context.Context) (*Company, error)
	predicates       []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Company entities.
func (m *CompanyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetBusinessNumber sets the "business_number" field.
func (m *CompanyMutation) SetBusinessNumber(s string) {
	m.business_number = &s
}

// BusinessNumber returns the value of the "business_number" field in the mutation.
func (m *CompanyMutation) BusinessNumber() (r string, exists bool) {
	v := m.business_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessNumber returns the old "business_number" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBusinessNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBusinessNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBusinessNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessNumber: %w", err)
	}
	return oldValue.BusinessNumber, nil
}

// ResetBusinessNumber resets all changes to the "business_number" field.
func (m *CompanyMutation) ResetBusinessNumber() {
	m.business_number = nil
}

// SetAddress sets the "address" field.
func (m *CompanyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CompanyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CompanyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[company.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CompanyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[company.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CompanyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, company.FieldAddress)
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CompanyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[company.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CompanyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[company.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, company.FieldDescription)
}

// SetProfileImage sets the "profile_image" field.
func (m *CompanyMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *CompanyMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *CompanyMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[company.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *CompanyMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[company.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *CompanyMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, company.FieldProfileImage)
}

// SetHompage sets the "hompage" field.
func (m *CompanyMutation) SetHompage(s string) {
	m.hompage = &s
}

// Hompage returns the value of the "hompage" field in the mutation.
func (m *CompanyMutation) Hompage() (r string, exists bool) {
	v := m.hompage
	if v == nil {
		return
	}
	return *v, true
}

// OldHompage returns the old "hompage" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldHompage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHompage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHompage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHompage: %w", err)
	}
	return oldValue.Hompage, nil
}

// ClearHompage clears the value of the "hompage" field.
func (m *CompanyMutation) ClearHompage() {
	m.hompage = nil
	m.clearedFields[company.FieldHompage] = struct{}{}
}

// HompageCleared returns if the "hompage" field was cleared in this mutation.
func (m *CompanyMutation) HompageCleared() bool {
	_, ok := m.clearedFields[company.FieldHompage]
	return ok
}

// ResetHompage resets all changes to the "hompage" field.
func (m *CompanyMutation) ResetHompage() {
	m.hompage = nil
	delete(m.clearedFields, company.FieldHompage)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CompanyMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CompanyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CompanyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CompanyMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CompanyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddProjectIDs adds the "project" edge to the Project entity by ids.
func (m *CompanyMutation) AddProjectIDs(ids ...int) {
	if m.project == nil {
		m.project = make(map[int]struct{})
	}
	for i := range ids {
		m.project[ids[i]] = struct{}{}
	}
}

// ClearProject clears the "project" edge to the Project entity.
func (m *CompanyMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *CompanyMutation) ProjectCleared() bool {
	return m.clearedproject
}

// RemoveProjectIDs removes the "project" edge to the Project entity by IDs.
func (m *CompanyMutation) RemoveProjectIDs(ids ...int) {
	if m.removedproject == nil {
		m.removedproject = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project, ids[i])
		m.removedproject[ids[i]] = struct{}{}
	}
}

// RemovedProject returns the removed IDs of the "project" edge to the Project entity.
func (m *CompanyMutation) RemovedProjectIDs() (ids []int) {
	for id := range m.removedproject {
		ids = append(ids, id)
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
func (m *CompanyMutation) ProjectIDs() (ids []int) {
	for id := range m.project {
		ids = append(ids, id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *CompanyMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
	m.removedproject = nil
}

// AddTaskTypeIDs adds the "task_type" edge to the TaskType entity by ids.
func (m *CompanyMutation) AddTaskTypeIDs(ids ...int) {
	if m.task_type == nil {
		m.task_type = make(map[int]struct{})
	}
	for i := range ids {
		m.task_type[ids[i]] = struct{}{}
	}
}

// ClearTaskType clears the "task_type" edge to the TaskType entity.
func (m *CompanyMutation) ClearTaskType() {
	m.clearedtask_type = true
}

// TaskTypeCleared reports if the "task_type" edge to the TaskType entity was cleared.
func (m *CompanyMutation) TaskTypeCleared() bool {
	return m.clearedtask_type
}

// RemoveTaskTypeIDs removes the "task_type" edge to the TaskType entity by IDs.
func (m *CompanyMutation) RemoveTaskTypeIDs(ids ...int) {
	if m.removedtask_type == nil {
		m.removedtask_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_type, ids[i])
		m.removedtask_type[ids[i]] = struct{}{}
	}
}

// RemovedTaskType returns the removed IDs of the "task_type" edge to the TaskType entity.
func (m *CompanyMutation) RemovedTaskTypeIDs() (ids []int) {
	for id := range m.removedtask_type {
		ids = append(ids, id)
	}
	return
}

// TaskTypeIDs returns the "task_type" edge IDs in the mutation.
func (m *CompanyMutation) TaskTypeIDs() (ids []int) {
	for id := range m.task_type {
		ids = append(ids, id)
	}
	return
}

// ResetTaskType resets all changes to the "task_type" edge.
func (m *CompanyMutation) ResetTaskType() {
	m.task_type = nil
	m.clearedtask_type = false
	m.removedtask_type = nil
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.business_number != nil {
		fields = append(fields, company.FieldBusinessNumber)
	}
	if m.address != nil {
		fields = append(fields, company.FieldAddress)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	if m.profile_image != nil {
		fields = append(fields, company.FieldProfileImage)
	}
	if m.hompage != nil {
		fields = append(fields, company.FieldHompage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	case company.FieldBusinessNumber:
		return m.BusinessNumber()
	case company.FieldAddress:
		return m.Address()
	case company.FieldDescription:
		return m.Description()
	case company.FieldProfileImage:
		return m.ProfileImage()
	case company.FieldHompage:
		return m.Hompage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldBusinessNumber:
		return m.OldBusinessNumber(ctx)
	case company.FieldAddress:
		return m.OldAddress(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	case company.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case company.FieldHompage:
		return m.OldHompage(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldBusinessNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessNumber(v)
		return nil
	case company.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case company.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case company.FieldHompage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHompage(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldAddress) {
		fields = append(fields, company.FieldAddress)
	}
	if m.FieldCleared(company.FieldDescription) {
		fields = append(fields, company.FieldDescription)
	}
	if m.FieldCleared(company.FieldProfileImage) {
		fields = append(fields, company.FieldProfileImage)
	}
	if m.FieldCleared(company.FieldHompage) {
		fields = append(fields, company.FieldHompage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldAddress:
		m.ClearAddress()
		return nil
	case company.FieldDescription:
		m.ClearDescription()
		return nil
	case company.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	case company.FieldHompage:
		m.ClearHompage()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldBusinessNumber:
		m.ResetBusinessNumber()
		return nil
	case company.FieldAddress:
		m.ResetAddress()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	case company.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case company.FieldHompage:
		m.ResetHompage()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, company.EdgeUser)
	}
	if m.project != nil {
		edges = append(edges, company.EdgeProject)
	}
	if m.task_type != nil {
		edges = append(edges, company.EdgeTaskType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case company.EdgeProject:
		ids := make([]ent.Value, 0, len(m.project))
		for id := range m.project {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.task_type))
		for id := range m.task_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproject != nil {
		edges = append(edges, company.EdgeProject)
	}
	if m.removedtask_type != nil {
		edges = append(edges, company.EdgeTaskType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeProject:
		ids := make([]ent.Value, 0, len(m.removedproject))
		for id := range m.removedproject {
			ids = append(ids, id)
		}
		return ids
	case company.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.removedtask_type))
		for id := range m.removedtask_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, company.EdgeUser)
	}
	if m.clearedproject {
		edges = append(edges, company.EdgeProject)
	}
	if m.clearedtask_type {
		edges = append(edges, company.EdgeTaskType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeUser:
		return m.cleareduser
	case company.EdgeProject:
		return m.clearedproject
	case company.EdgeTaskType:
		return m.clearedtask_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeUser:
		m.ResetUser()
		return nil
	case company.EdgeProject:
		m.ResetProject()
		return nil
	case company.EdgeTaskType:
		m.ResetTaskType()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// ProjectMutation represents an operation that mutates the Project nodes in the graph.
type ProjectMutation struct {
	config
	op                  Op
	typ                 string
	id                  *int
	name                *string
	content             *string
	start_date          *string
	end_date            *string
	applying_start_date *string
	applying_end_date   *string
	qualification       *string
	task_experience     *string
	profile_image       *string
	created_at          *time.Time
	sponsor_fee         *int
	addsponsor_fee      *int
	clearedFields       map[string]struct{}
	company             *int
	clearedcompany      bool
	club                *int
	clearedclub         bool
	project_club        map[int]struct{}
	removedproject_club map[int]struct{}
	clearedproject_club bool
	project_log         map[int]struct{}
	removedproject_log  map[int]struct{}
	clearedproject_log  bool
	task_type           map[int]struct{}
	removedtask_type    map[int]struct{}
	clearedtask_type    bool
	done                bool
	oldValue            func(context.Context) (*Project, error)
	predicates          []predicate.Project
}

var _ ent.Mutation = (*ProjectMutation)(nil)

// projectOption allows management of the mutation configuration using functional options.
type projectOption func(*ProjectMutation)

// newProjectMutation creates new mutation for the Project entity.
func newProjectMutation(c config, op Op, opts ...projectOption) *ProjectMutation {
	m := &ProjectMutation{
		config:        c,
		op:            op,
		typ:           TypeProject,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectID sets the ID field of the mutation.
func withProjectID(id int) projectOption {
	return func(m *ProjectMutation) {
		var (
			err   error
			once  sync.Once
			value *Project
		)
		m.oldValue = func(ctx context.Context) (*Project, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Project.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProject sets the old Project of the mutation.
func withProject(node *Project) projectOption {
	return func(m *ProjectMutation) {
		m.oldValue = func(context.Context) (*Project, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectMutation) ResetName() {
	m.name = nil
}

// SetContent sets the "content" field.
func (m *ProjectMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ProjectMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ProjectMutation) ResetContent() {
	m.content = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectMutation) SetStartDate(s string) {
	m.start_date = &s
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectMutation) StartDate() (r string, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldStartDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ProjectMutation) SetEndDate(s string) {
	m.end_date = &s
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectMutation) EndDate() (r string, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldEndDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectMutation) ResetEndDate() {
	m.end_date = nil
}

// SetApplyingStartDate sets the "applying_start_date" field.
func (m *ProjectMutation) SetApplyingStartDate(s string) {
	m.applying_start_date = &s
}

// ApplyingStartDate returns the value of the "applying_start_date" field in the mutation.
func (m *ProjectMutation) ApplyingStartDate() (r string, exists bool) {
	v := m.applying_start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyingStartDate returns the old "applying_start_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldApplyingStartDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyingStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyingStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyingStartDate: %w", err)
	}
	return oldValue.ApplyingStartDate, nil
}

// ResetApplyingStartDate resets all changes to the "applying_start_date" field.
func (m *ProjectMutation) ResetApplyingStartDate() {
	m.applying_start_date = nil
}

// SetApplyingEndDate sets the "applying_end_date" field.
func (m *ProjectMutation) SetApplyingEndDate(s string) {
	m.applying_end_date = &s
}

// ApplyingEndDate returns the value of the "applying_end_date" field in the mutation.
func (m *ProjectMutation) ApplyingEndDate() (r string, exists bool) {
	v := m.applying_end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldApplyingEndDate returns the old "applying_end_date" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldApplyingEndDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldApplyingEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldApplyingEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldApplyingEndDate: %w", err)
	}
	return oldValue.ApplyingEndDate, nil
}

// ResetApplyingEndDate resets all changes to the "applying_end_date" field.
func (m *ProjectMutation) ResetApplyingEndDate() {
	m.applying_end_date = nil
}

// SetQualification sets the "qualification" field.
func (m *ProjectMutation) SetQualification(s string) {
	m.qualification = &s
}

// Qualification returns the value of the "qualification" field in the mutation.
func (m *ProjectMutation) Qualification() (r string, exists bool) {
	v := m.qualification
	if v == nil {
		return
	}
	return *v, true
}

// OldQualification returns the old "qualification" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldQualification(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldQualification is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldQualification requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldQualification: %w", err)
	}
	return oldValue.Qualification, nil
}

// ResetQualification resets all changes to the "qualification" field.
func (m *ProjectMutation) ResetQualification() {
	m.qualification = nil
}

// SetTaskExperience sets the "task_experience" field.
func (m *ProjectMutation) SetTaskExperience(s string) {
	m.task_experience = &s
}

// TaskExperience returns the value of the "task_experience" field in the mutation.
func (m *ProjectMutation) TaskExperience() (r string, exists bool) {
	v := m.task_experience
	if v == nil {
		return
	}
	return *v, true
}

// OldTaskExperience returns the old "task_experience" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldTaskExperience(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTaskExperience is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTaskExperience requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTaskExperience: %w", err)
	}
	return oldValue.TaskExperience, nil
}

// ClearTaskExperience clears the value of the "task_experience" field.
func (m *ProjectMutation) ClearTaskExperience() {
	m.task_experience = nil
	m.clearedFields[project.FieldTaskExperience] = struct{}{}
}

// TaskExperienceCleared returns if the "task_experience" field was cleared in this mutation.
func (m *ProjectMutation) TaskExperienceCleared() bool {
	_, ok := m.clearedFields[project.FieldTaskExperience]
	return ok
}

// ResetTaskExperience resets all changes to the "task_experience" field.
func (m *ProjectMutation) ResetTaskExperience() {
	m.task_experience = nil
	delete(m.clearedFields, project.FieldTaskExperience)
}

// SetProfileImage sets the "profile_image" field.
func (m *ProjectMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *ProjectMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *ProjectMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[project.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *ProjectMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[project.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *ProjectMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, project.FieldProfileImage)
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetSponsorFee sets the "sponsor_fee" field.
func (m *ProjectMutation) SetSponsorFee(i int) {
	m.sponsor_fee = &i
	m.addsponsor_fee = nil
}

// SponsorFee returns the value of the "sponsor_fee" field in the mutation.
func (m *ProjectMutation) SponsorFee() (r int, exists bool) {
	v := m.sponsor_fee
	if v == nil {
		return
	}
	return *v, true
}

// OldSponsorFee returns the old "sponsor_fee" field's value of the Project entity.
// If the Project object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectMutation) OldSponsorFee(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSponsorFee is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSponsorFee requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSponsorFee: %w", err)
	}
	return oldValue.SponsorFee, nil
}

// AddSponsorFee adds i to the "sponsor_fee" field.
func (m *ProjectMutation) AddSponsorFee(i int) {
	if m.addsponsor_fee != nil {
		*m.addsponsor_fee += i
	} else {
		m.addsponsor_fee = &i
	}
}

// AddedSponsorFee returns the value that was added to the "sponsor_fee" field in this mutation.
func (m *ProjectMutation) AddedSponsorFee() (r int, exists bool) {
	v := m.addsponsor_fee
	if v == nil {
		return
	}
	return *v, true
}

// ResetSponsorFee resets all changes to the "sponsor_fee" field.
func (m *ProjectMutation) ResetSponsorFee() {
	m.sponsor_fee = nil
	m.addsponsor_fee = nil
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *ProjectMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *ProjectMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *ProjectMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *ProjectMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *ProjectMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetClubID sets the "club" edge to the Club entity by id.
func (m *ProjectMutation) SetClubID(id int) {
	m.club = &id
}

// ClearClub clears the "club" edge to the Club entity.
func (m *ProjectMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *ProjectMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubID returns the "club" edge ID in the mutation.
func (m *ProjectMutation) ClubID() (id int, exists bool) {
	if m.club != nil {
		return *m.club, true
	}
	return
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ProjectMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *ProjectMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// AddProjectClubIDs adds the "project_club" edge to the ProjectClub entity by ids.
func (m *ProjectMutation) AddProjectClubIDs(ids ...int) {
	if m.project_club == nil {
		m.project_club = make(map[int]struct{})
	}
	for i := range ids {
		m.project_club[ids[i]] = struct{}{}
	}
}

// ClearProjectClub clears the "project_club" edge to the ProjectClub entity.
func (m *ProjectMutation) ClearProjectClub() {
	m.clearedproject_club = true
}

// ProjectClubCleared reports if the "project_club" edge to the ProjectClub entity was cleared.
func (m *ProjectMutation) ProjectClubCleared() bool {
	return m.clearedproject_club
}

// RemoveProjectClubIDs removes the "project_club" edge to the ProjectClub entity by IDs.
func (m *ProjectMutation) RemoveProjectClubIDs(ids ...int) {
	if m.removedproject_club == nil {
		m.removedproject_club = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_club, ids[i])
		m.removedproject_club[ids[i]] = struct{}{}
	}
}

// RemovedProjectClub returns the removed IDs of the "project_club" edge to the ProjectClub entity.
func (m *ProjectMutation) RemovedProjectClubIDs() (ids []int) {
	for id := range m.removedproject_club {
		ids = append(ids, id)
	}
	return
}

// ProjectClubIDs returns the "project_club" edge IDs in the mutation.
func (m *ProjectMutation) ProjectClubIDs() (ids []int) {
	for id := range m.project_club {
		ids = append(ids, id)
	}
	return
}

// ResetProjectClub resets all changes to the "project_club" edge.
func (m *ProjectMutation) ResetProjectClub() {
	m.project_club = nil
	m.clearedproject_club = false
	m.removedproject_club = nil
}

// AddProjectLogIDs adds the "project_log" edge to the ProjectLog entity by ids.
func (m *ProjectMutation) AddProjectLogIDs(ids ...int) {
	if m.project_log == nil {
		m.project_log = make(map[int]struct{})
	}
	for i := range ids {
		m.project_log[ids[i]] = struct{}{}
	}
}

// ClearProjectLog clears the "project_log" edge to the ProjectLog entity.
func (m *ProjectMutation) ClearProjectLog() {
	m.clearedproject_log = true
}

// ProjectLogCleared reports if the "project_log" edge to the ProjectLog entity was cleared.
func (m *ProjectMutation) ProjectLogCleared() bool {
	return m.clearedproject_log
}

// RemoveProjectLogIDs removes the "project_log" edge to the ProjectLog entity by IDs.
func (m *ProjectMutation) RemoveProjectLogIDs(ids ...int) {
	if m.removedproject_log == nil {
		m.removedproject_log = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_log, ids[i])
		m.removedproject_log[ids[i]] = struct{}{}
	}
}

// RemovedProjectLog returns the removed IDs of the "project_log" edge to the ProjectLog entity.
func (m *ProjectMutation) RemovedProjectLogIDs() (ids []int) {
	for id := range m.removedproject_log {
		ids = append(ids, id)
	}
	return
}

// ProjectLogIDs returns the "project_log" edge IDs in the mutation.
func (m *ProjectMutation) ProjectLogIDs() (ids []int) {
	for id := range m.project_log {
		ids = append(ids, id)
	}
	return
}

// ResetProjectLog resets all changes to the "project_log" edge.
func (m *ProjectMutation) ResetProjectLog() {
	m.project_log = nil
	m.clearedproject_log = false
	m.removedproject_log = nil
}

// AddTaskTypeIDs adds the "task_type" edge to the TaskType entity by ids.
func (m *ProjectMutation) AddTaskTypeIDs(ids ...int) {
	if m.task_type == nil {
		m.task_type = make(map[int]struct{})
	}
	for i := range ids {
		m.task_type[ids[i]] = struct{}{}
	}
}

// ClearTaskType clears the "task_type" edge to the TaskType entity.
func (m *ProjectMutation) ClearTaskType() {
	m.clearedtask_type = true
}

// TaskTypeCleared reports if the "task_type" edge to the TaskType entity was cleared.
func (m *ProjectMutation) TaskTypeCleared() bool {
	return m.clearedtask_type
}

// RemoveTaskTypeIDs removes the "task_type" edge to the TaskType entity by IDs.
func (m *ProjectMutation) RemoveTaskTypeIDs(ids ...int) {
	if m.removedtask_type == nil {
		m.removedtask_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_type, ids[i])
		m.removedtask_type[ids[i]] = struct{}{}
	}
}

// RemovedTaskType returns the removed IDs of the "task_type" edge to the TaskType entity.
func (m *ProjectMutation) RemovedTaskTypeIDs() (ids []int) {
	for id := range m.removedtask_type {
		ids = append(ids, id)
	}
	return
}

// TaskTypeIDs returns the "task_type" edge IDs in the mutation.
func (m *ProjectMutation) TaskTypeIDs() (ids []int) {
	for id := range m.task_type {
		ids = append(ids, id)
	}
	return
}

// ResetTaskType resets all changes to the "task_type" edge.
func (m *ProjectMutation) ResetTaskType() {
	m.task_type = nil
	m.clearedtask_type = false
	m.removedtask_type = nil
}

// Where appends a list predicates to the ProjectMutation builder.
func (m *ProjectMutation) Where(ps ...predicate.Project) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Project).
func (m *ProjectMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.name != nil {
		fields = append(fields, project.FieldName)
	}
	if m.content != nil {
		fields = append(fields, project.FieldContent)
	}
	if m.start_date != nil {
		fields = append(fields, project.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, project.FieldEndDate)
	}
	if m.applying_start_date != nil {
		fields = append(fields, project.FieldApplyingStartDate)
	}
	if m.applying_end_date != nil {
		fields = append(fields, project.FieldApplyingEndDate)
	}
	if m.qualification != nil {
		fields = append(fields, project.FieldQualification)
	}
	if m.task_experience != nil {
		fields = append(fields, project.FieldTaskExperience)
	}
	if m.profile_image != nil {
		fields = append(fields, project.FieldProfileImage)
	}
	if m.created_at != nil {
		fields = append(fields, project.FieldCreatedAt)
	}
	if m.sponsor_fee != nil {
		fields = append(fields, project.FieldSponsorFee)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case project.FieldName:
		return m.Name()
	case project.FieldContent:
		return m.Content()
	case project.FieldStartDate:
		return m.StartDate()
	case project.FieldEndDate:
		return m.EndDate()
	case project.FieldApplyingStartDate:
		return m.ApplyingStartDate()
	case project.FieldApplyingEndDate:
		return m.ApplyingEndDate()
	case project.FieldQualification:
		return m.Qualification()
	case project.FieldTaskExperience:
		return m.TaskExperience()
	case project.FieldProfileImage:
		return m.ProfileImage()
	case project.FieldCreatedAt:
		return m.CreatedAt()
	case project.FieldSponsorFee:
		return m.SponsorFee()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case project.FieldName:
		return m.OldName(ctx)
	case project.FieldContent:
		return m.OldContent(ctx)
	case project.FieldStartDate:
		return m.OldStartDate(ctx)
	case project.FieldEndDate:
		return m.OldEndDate(ctx)
	case project.FieldApplyingStartDate:
		return m.OldApplyingStartDate(ctx)
	case project.FieldApplyingEndDate:
		return m.OldApplyingEndDate(ctx)
	case project.FieldQualification:
		return m.OldQualification(ctx)
	case project.FieldTaskExperience:
		return m.OldTaskExperience(ctx)
	case project.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case project.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case project.FieldSponsorFee:
		return m.OldSponsorFee(ctx)
	}
	return nil, fmt.Errorf("unknown Project field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) SetField(name string, value ent.Value) error {
	switch name {
	case project.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case project.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case project.FieldStartDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case project.FieldEndDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case project.FieldApplyingStartDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyingStartDate(v)
		return nil
	case project.FieldApplyingEndDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetApplyingEndDate(v)
		return nil
	case project.FieldQualification:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetQualification(v)
		return nil
	case project.FieldTaskExperience:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTaskExperience(v)
		return nil
	case project.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case project.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case project.FieldSponsorFee:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSponsorFee(v)
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectMutation) AddedFields() []string {
	var fields []string
	if m.addsponsor_fee != nil {
		fields = append(fields, project.FieldSponsorFee)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case project.FieldSponsorFee:
		return m.AddedSponsorFee()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectMutation) AddField(name string, value ent.Value) error {
	switch name {
	case project.FieldSponsorFee:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSponsorFee(v)
		return nil
	}
	return fmt.Errorf("unknown Project numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(project.FieldTaskExperience) {
		fields = append(fields, project.FieldTaskExperience)
	}
	if m.FieldCleared(project.FieldProfileImage) {
		fields = append(fields, project.FieldProfileImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectMutation) ClearField(name string) error {
	switch name {
	case project.FieldTaskExperience:
		m.ClearTaskExperience()
		return nil
	case project.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	}
	return fmt.Errorf("unknown Project nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectMutation) ResetField(name string) error {
	switch name {
	case project.FieldName:
		m.ResetName()
		return nil
	case project.FieldContent:
		m.ResetContent()
		return nil
	case project.FieldStartDate:
		m.ResetStartDate()
		return nil
	case project.FieldEndDate:
		m.ResetEndDate()
		return nil
	case project.FieldApplyingStartDate:
		m.ResetApplyingStartDate()
		return nil
	case project.FieldApplyingEndDate:
		m.ResetApplyingEndDate()
		return nil
	case project.FieldQualification:
		m.ResetQualification()
		return nil
	case project.FieldTaskExperience:
		m.ResetTaskExperience()
		return nil
	case project.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case project.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case project.FieldSponsorFee:
		m.ResetSponsorFee()
		return nil
	}
	return fmt.Errorf("unknown Project field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.company != nil {
		edges = append(edges, project.EdgeCompany)
	}
	if m.club != nil {
		edges = append(edges, project.EdgeClub)
	}
	if m.project_club != nil {
		edges = append(edges, project.EdgeProjectClub)
	}
	if m.project_log != nil {
		edges = append(edges, project.EdgeProjectLog)
	}
	if m.task_type != nil {
		edges = append(edges, project.EdgeTaskType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	case project.EdgeProjectClub:
		ids := make([]ent.Value, 0, len(m.project_club))
		for id := range m.project_club {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectLog:
		ids := make([]ent.Value, 0, len(m.project_log))
		for id := range m.project_log {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.task_type))
		for id := range m.task_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedproject_club != nil {
		edges = append(edges, project.EdgeProjectClub)
	}
	if m.removedproject_log != nil {
		edges = append(edges, project.EdgeProjectLog)
	}
	if m.removedtask_type != nil {
		edges = append(edges, project.EdgeTaskType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case project.EdgeProjectClub:
		ids := make([]ent.Value, 0, len(m.removedproject_club))
		for id := range m.removedproject_club {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeProjectLog:
		ids := make([]ent.Value, 0, len(m.removedproject_log))
		for id := range m.removedproject_log {
			ids = append(ids, id)
		}
		return ids
	case project.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.removedtask_type))
		for id := range m.removedtask_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcompany {
		edges = append(edges, project.EdgeCompany)
	}
	if m.clearedclub {
		edges = append(edges, project.EdgeClub)
	}
	if m.clearedproject_club {
		edges = append(edges, project.EdgeProjectClub)
	}
	if m.clearedproject_log {
		edges = append(edges, project.EdgeProjectLog)
	}
	if m.clearedtask_type {
		edges = append(edges, project.EdgeTaskType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectMutation) EdgeCleared(name string) bool {
	switch name {
	case project.EdgeCompany:
		return m.clearedcompany
	case project.EdgeClub:
		return m.clearedclub
	case project.EdgeProjectClub:
		return m.clearedproject_club
	case project.EdgeProjectLog:
		return m.clearedproject_log
	case project.EdgeTaskType:
		return m.clearedtask_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectMutation) ClearEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ClearCompany()
		return nil
	case project.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown Project unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectMutation) ResetEdge(name string) error {
	switch name {
	case project.EdgeCompany:
		m.ResetCompany()
		return nil
	case project.EdgeClub:
		m.ResetClub()
		return nil
	case project.EdgeProjectClub:
		m.ResetProjectClub()
		return nil
	case project.EdgeProjectLog:
		m.ResetProjectLog()
		return nil
	case project.EdgeTaskType:
		m.ResetTaskType()
		return nil
	}
	return fmt.Errorf("unknown Project edge %s", name)
}

// ProjectClubMutation represents an operation that mutates the ProjectClub nodes in the graph.
type ProjectClubMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	start_date         *string
	clearedFields      map[string]struct{}
	club               *int
	clearedclub        bool
	project            *int
	clearedproject     bool
	project_log        map[int]struct{}
	removedproject_log map[int]struct{}
	clearedproject_log bool
	done               bool
	oldValue           func(context.Context) (*ProjectClub, error)
	predicates         []predicate.ProjectClub
}

var _ ent.Mutation = (*ProjectClubMutation)(nil)

// projectclubOption allows management of the mutation configuration using functional options.
type projectclubOption func(*ProjectClubMutation)

// newProjectClubMutation creates new mutation for the ProjectClub entity.
func newProjectClubMutation(c config, op Op, opts ...projectclubOption) *ProjectClubMutation {
	m := &ProjectClubMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectClubID sets the ID field of the mutation.
func withProjectClubID(id int) projectclubOption {
	return func(m *ProjectClubMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectClub
		)
		m.oldValue = func(ctx context.Context) (*ProjectClub, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectClub.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectClub sets the old ProjectClub of the mutation.
func withProjectClub(node *ProjectClub) projectclubOption {
	return func(m *ProjectClubMutation) {
		m.oldValue = func(context.Context) (*ProjectClub, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectClubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClubID sets the "club_id" field.
func (m *ProjectClubMutation) SetClubID(i int) {
	m.club = &i
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *ProjectClubMutation) ClubID() (r int, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the ProjectClub entity.
// If the ProjectClub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectClubMutation) OldClubID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *ProjectClubMutation) ResetClubID() {
	m.club = nil
}

// SetProjectID sets the "project_id" field.
func (m *ProjectClubMutation) SetProjectID(i int) {
	m.project = &i
}

// ProjectID returns the value of the "project_id" field in the mutation.
func (m *ProjectClubMutation) ProjectID() (r int, exists bool) {
	v := m.project
	if v == nil {
		return
	}
	return *v, true
}

// OldProjectID returns the old "project_id" field's value of the ProjectClub entity.
// If the ProjectClub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectClubMutation) OldProjectID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProjectID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProjectID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProjectID: %w", err)
	}
	return oldValue.ProjectID, nil
}

// ResetProjectID resets all changes to the "project_id" field.
func (m *ProjectClubMutation) ResetProjectID() {
	m.project = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectClubMutation) SetStartDate(s string) {
	m.start_date = &s
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectClubMutation) StartDate() (r string, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ProjectClub entity.
// If the ProjectClub object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectClubMutation) OldStartDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectClubMutation) ResetStartDate() {
	m.start_date = nil
}

// ClearClub clears the "club" edge to the Club entity.
func (m *ProjectClubMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *ProjectClubMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ProjectClubMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *ProjectClubMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectClubMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectClubMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectClubMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectClubMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// AddProjectLogIDs adds the "project_log" edge to the ProjectLog entity by ids.
func (m *ProjectClubMutation) AddProjectLogIDs(ids ...int) {
	if m.project_log == nil {
		m.project_log = make(map[int]struct{})
	}
	for i := range ids {
		m.project_log[ids[i]] = struct{}{}
	}
}

// ClearProjectLog clears the "project_log" edge to the ProjectLog entity.
func (m *ProjectClubMutation) ClearProjectLog() {
	m.clearedproject_log = true
}

// ProjectLogCleared reports if the "project_log" edge to the ProjectLog entity was cleared.
func (m *ProjectClubMutation) ProjectLogCleared() bool {
	return m.clearedproject_log
}

// RemoveProjectLogIDs removes the "project_log" edge to the ProjectLog entity by IDs.
func (m *ProjectClubMutation) RemoveProjectLogIDs(ids ...int) {
	if m.removedproject_log == nil {
		m.removedproject_log = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_log, ids[i])
		m.removedproject_log[ids[i]] = struct{}{}
	}
}

// RemovedProjectLog returns the removed IDs of the "project_log" edge to the ProjectLog entity.
func (m *ProjectClubMutation) RemovedProjectLogIDs() (ids []int) {
	for id := range m.removedproject_log {
		ids = append(ids, id)
	}
	return
}

// ProjectLogIDs returns the "project_log" edge IDs in the mutation.
func (m *ProjectClubMutation) ProjectLogIDs() (ids []int) {
	for id := range m.project_log {
		ids = append(ids, id)
	}
	return
}

// ResetProjectLog resets all changes to the "project_log" edge.
func (m *ProjectClubMutation) ResetProjectLog() {
	m.project_log = nil
	m.clearedproject_log = false
	m.removedproject_log = nil
}

// Where appends a list predicates to the ProjectClubMutation builder.
func (m *ProjectClubMutation) Where(ps ...predicate.ProjectClub) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectClubMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectClub).
func (m *ProjectClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectClubMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.club != nil {
		fields = append(fields, projectclub.FieldClubID)
	}
	if m.project != nil {
		fields = append(fields, projectclub.FieldProjectID)
	}
	if m.start_date != nil {
		fields = append(fields, projectclub.FieldStartDate)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectclub.FieldClubID:
		return m.ClubID()
	case projectclub.FieldProjectID:
		return m.ProjectID()
	case projectclub.FieldStartDate:
		return m.StartDate()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectclub.FieldClubID:
		return m.OldClubID(ctx)
	case projectclub.FieldProjectID:
		return m.OldProjectID(ctx)
	case projectclub.FieldStartDate:
		return m.OldStartDate(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectClub field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectclub.FieldClubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	case projectclub.FieldProjectID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProjectID(v)
		return nil
	case projectclub.FieldStartDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectClub field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectClubMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectClubMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectClub numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectClubMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectClubMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectClub nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectClubMutation) ResetField(name string) error {
	switch name {
	case projectclub.FieldClubID:
		m.ResetClubID()
		return nil
	case projectclub.FieldProjectID:
		m.ResetProjectID()
		return nil
	case projectclub.FieldStartDate:
		m.ResetStartDate()
		return nil
	}
	return fmt.Errorf("unknown ProjectClub field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.club != nil {
		edges = append(edges, projectclub.EdgeClub)
	}
	if m.project != nil {
		edges = append(edges, projectclub.EdgeProject)
	}
	if m.project_log != nil {
		edges = append(edges, projectclub.EdgeProjectLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectclub.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	case projectclub.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectclub.EdgeProjectLog:
		ids := make([]ent.Value, 0, len(m.project_log))
		for id := range m.project_log {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedproject_log != nil {
		edges = append(edges, projectclub.EdgeProjectLog)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectclub.EdgeProjectLog:
		ids := make([]ent.Value, 0, len(m.removedproject_log))
		for id := range m.removedproject_log {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedclub {
		edges = append(edges, projectclub.EdgeClub)
	}
	if m.clearedproject {
		edges = append(edges, projectclub.EdgeProject)
	}
	if m.clearedproject_log {
		edges = append(edges, projectclub.EdgeProjectLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectClubMutation) EdgeCleared(name string) bool {
	switch name {
	case projectclub.EdgeClub:
		return m.clearedclub
	case projectclub.EdgeProject:
		return m.clearedproject
	case projectclub.EdgeProjectLog:
		return m.clearedproject_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectClubMutation) ClearEdge(name string) error {
	switch name {
	case projectclub.EdgeClub:
		m.ClearClub()
		return nil
	case projectclub.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown ProjectClub unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectClubMutation) ResetEdge(name string) error {
	switch name {
	case projectclub.EdgeClub:
		m.ResetClub()
		return nil
	case projectclub.EdgeProject:
		m.ResetProject()
		return nil
	case projectclub.EdgeProjectLog:
		m.ResetProjectLog()
		return nil
	}
	return fmt.Errorf("unknown ProjectClub edge %s", name)
}

// ProjectLogMutation represents an operation that mutates the ProjectLog nodes in the graph.
type ProjectLogMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int
	title                          *string
	author                         *string
	content                        *string
	start_date                     *string
	end_date                       *string
	created_at                     *time.Time
	clearedFields                  map[string]struct{}
	project                        *int
	clearedproject                 bool
	project_club                   *int
	clearedproject_club            bool
	project_log_participant        map[int]struct{}
	removedproject_log_participant map[int]struct{}
	clearedproject_log_participant bool
	project_log_feedback           map[int]struct{}
	removedproject_log_feedback    map[int]struct{}
	clearedproject_log_feedback    bool
	done                           bool
	oldValue                       func(context.Context) (*ProjectLog, error)
	predicates                     []predicate.ProjectLog
}

var _ ent.Mutation = (*ProjectLogMutation)(nil)

// projectlogOption allows management of the mutation configuration using functional options.
type projectlogOption func(*ProjectLogMutation)

// newProjectLogMutation creates new mutation for the ProjectLog entity.
func newProjectLogMutation(c config, op Op, opts ...projectlogOption) *ProjectLogMutation {
	m := &ProjectLogMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectLog,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectLogID sets the ID field of the mutation.
func withProjectLogID(id int) projectlogOption {
	return func(m *ProjectLogMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectLog
		)
		m.oldValue = func(ctx context.Context) (*ProjectLog, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectLog.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectLog sets the old ProjectLog of the mutation.
func withProjectLog(node *ProjectLog) projectlogOption {
	return func(m *ProjectLogMutation) {
		m.oldValue = func(context.Context) (*ProjectLog, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectLogMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectLogMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectLogMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetTitle sets the "title" field.
func (m *ProjectLogMutation) SetTitle(s string) {
	m.title = &s
}

// Title returns the value of the "title" field in the mutation.
func (m *ProjectLogMutation) Title() (r string, exists bool) {
	v := m.title
	if v == nil {
		return
	}
	return *v, true
}

// OldTitle returns the old "title" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldTitle(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTitle is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTitle requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTitle: %w", err)
	}
	return oldValue.Title, nil
}

// ResetTitle resets all changes to the "title" field.
func (m *ProjectLogMutation) ResetTitle() {
	m.title = nil
}

// SetAuthor sets the "author" field.
func (m *ProjectLogMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ProjectLogMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ProjectLogMutation) ResetAuthor() {
	m.author = nil
}

// SetContent sets the "content" field.
func (m *ProjectLogMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ProjectLogMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ProjectLogMutation) ResetContent() {
	m.content = nil
}

// SetStartDate sets the "start_date" field.
func (m *ProjectLogMutation) SetStartDate(s string) {
	m.start_date = &s
}

// StartDate returns the value of the "start_date" field in the mutation.
func (m *ProjectLogMutation) StartDate() (r string, exists bool) {
	v := m.start_date
	if v == nil {
		return
	}
	return *v, true
}

// OldStartDate returns the old "start_date" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldStartDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStartDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStartDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStartDate: %w", err)
	}
	return oldValue.StartDate, nil
}

// ResetStartDate resets all changes to the "start_date" field.
func (m *ProjectLogMutation) ResetStartDate() {
	m.start_date = nil
}

// SetEndDate sets the "end_date" field.
func (m *ProjectLogMutation) SetEndDate(s string) {
	m.end_date = &s
}

// EndDate returns the value of the "end_date" field in the mutation.
func (m *ProjectLogMutation) EndDate() (r string, exists bool) {
	v := m.end_date
	if v == nil {
		return
	}
	return *v, true
}

// OldEndDate returns the old "end_date" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldEndDate(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEndDate is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEndDate requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEndDate: %w", err)
	}
	return oldValue.EndDate, nil
}

// ResetEndDate resets all changes to the "end_date" field.
func (m *ProjectLogMutation) ResetEndDate() {
	m.end_date = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *ProjectLogMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ProjectLogMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the ProjectLog entity.
// If the ProjectLog object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ClearCreatedAt clears the value of the "created_at" field.
func (m *ProjectLogMutation) ClearCreatedAt() {
	m.created_at = nil
	m.clearedFields[projectlog.FieldCreatedAt] = struct{}{}
}

// CreatedAtCleared returns if the "created_at" field was cleared in this mutation.
func (m *ProjectLogMutation) CreatedAtCleared() bool {
	_, ok := m.clearedFields[projectlog.FieldCreatedAt]
	return ok
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ProjectLogMutation) ResetCreatedAt() {
	m.created_at = nil
	delete(m.clearedFields, projectlog.FieldCreatedAt)
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *ProjectLogMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *ProjectLogMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *ProjectLogMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *ProjectLogMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *ProjectLogMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *ProjectLogMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// SetProjectClubID sets the "project_club" edge to the ProjectClub entity by id.
func (m *ProjectLogMutation) SetProjectClubID(id int) {
	m.project_club = &id
}

// ClearProjectClub clears the "project_club" edge to the ProjectClub entity.
func (m *ProjectLogMutation) ClearProjectClub() {
	m.clearedproject_club = true
}

// ProjectClubCleared reports if the "project_club" edge to the ProjectClub entity was cleared.
func (m *ProjectLogMutation) ProjectClubCleared() bool {
	return m.clearedproject_club
}

// ProjectClubID returns the "project_club" edge ID in the mutation.
func (m *ProjectLogMutation) ProjectClubID() (id int, exists bool) {
	if m.project_club != nil {
		return *m.project_club, true
	}
	return
}

// ProjectClubIDs returns the "project_club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectClubID instead. It exists only for internal usage by the builders.
func (m *ProjectLogMutation) ProjectClubIDs() (ids []int) {
	if id := m.project_club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectClub resets all changes to the "project_club" edge.
func (m *ProjectLogMutation) ResetProjectClub() {
	m.project_club = nil
	m.clearedproject_club = false
}

// AddProjectLogParticipantIDs adds the "project_log_participant" edge to the ProjectLogParticipant entity by ids.
func (m *ProjectLogMutation) AddProjectLogParticipantIDs(ids ...int) {
	if m.project_log_participant == nil {
		m.project_log_participant = make(map[int]struct{})
	}
	for i := range ids {
		m.project_log_participant[ids[i]] = struct{}{}
	}
}

// ClearProjectLogParticipant clears the "project_log_participant" edge to the ProjectLogParticipant entity.
func (m *ProjectLogMutation) ClearProjectLogParticipant() {
	m.clearedproject_log_participant = true
}

// ProjectLogParticipantCleared reports if the "project_log_participant" edge to the ProjectLogParticipant entity was cleared.
func (m *ProjectLogMutation) ProjectLogParticipantCleared() bool {
	return m.clearedproject_log_participant
}

// RemoveProjectLogParticipantIDs removes the "project_log_participant" edge to the ProjectLogParticipant entity by IDs.
func (m *ProjectLogMutation) RemoveProjectLogParticipantIDs(ids ...int) {
	if m.removedproject_log_participant == nil {
		m.removedproject_log_participant = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_log_participant, ids[i])
		m.removedproject_log_participant[ids[i]] = struct{}{}
	}
}

// RemovedProjectLogParticipant returns the removed IDs of the "project_log_participant" edge to the ProjectLogParticipant entity.
func (m *ProjectLogMutation) RemovedProjectLogParticipantIDs() (ids []int) {
	for id := range m.removedproject_log_participant {
		ids = append(ids, id)
	}
	return
}

// ProjectLogParticipantIDs returns the "project_log_participant" edge IDs in the mutation.
func (m *ProjectLogMutation) ProjectLogParticipantIDs() (ids []int) {
	for id := range m.project_log_participant {
		ids = append(ids, id)
	}
	return
}

// ResetProjectLogParticipant resets all changes to the "project_log_participant" edge.
func (m *ProjectLogMutation) ResetProjectLogParticipant() {
	m.project_log_participant = nil
	m.clearedproject_log_participant = false
	m.removedproject_log_participant = nil
}

// AddProjectLogFeedbackIDs adds the "project_log_feedback" edge to the ProjectLogFeedback entity by ids.
func (m *ProjectLogMutation) AddProjectLogFeedbackIDs(ids ...int) {
	if m.project_log_feedback == nil {
		m.project_log_feedback = make(map[int]struct{})
	}
	for i := range ids {
		m.project_log_feedback[ids[i]] = struct{}{}
	}
}

// ClearProjectLogFeedback clears the "project_log_feedback" edge to the ProjectLogFeedback entity.
func (m *ProjectLogMutation) ClearProjectLogFeedback() {
	m.clearedproject_log_feedback = true
}

// ProjectLogFeedbackCleared reports if the "project_log_feedback" edge to the ProjectLogFeedback entity was cleared.
func (m *ProjectLogMutation) ProjectLogFeedbackCleared() bool {
	return m.clearedproject_log_feedback
}

// RemoveProjectLogFeedbackIDs removes the "project_log_feedback" edge to the ProjectLogFeedback entity by IDs.
func (m *ProjectLogMutation) RemoveProjectLogFeedbackIDs(ids ...int) {
	if m.removedproject_log_feedback == nil {
		m.removedproject_log_feedback = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.project_log_feedback, ids[i])
		m.removedproject_log_feedback[ids[i]] = struct{}{}
	}
}

// RemovedProjectLogFeedback returns the removed IDs of the "project_log_feedback" edge to the ProjectLogFeedback entity.
func (m *ProjectLogMutation) RemovedProjectLogFeedbackIDs() (ids []int) {
	for id := range m.removedproject_log_feedback {
		ids = append(ids, id)
	}
	return
}

// ProjectLogFeedbackIDs returns the "project_log_feedback" edge IDs in the mutation.
func (m *ProjectLogMutation) ProjectLogFeedbackIDs() (ids []int) {
	for id := range m.project_log_feedback {
		ids = append(ids, id)
	}
	return
}

// ResetProjectLogFeedback resets all changes to the "project_log_feedback" edge.
func (m *ProjectLogMutation) ResetProjectLogFeedback() {
	m.project_log_feedback = nil
	m.clearedproject_log_feedback = false
	m.removedproject_log_feedback = nil
}

// Where appends a list predicates to the ProjectLogMutation builder.
func (m *ProjectLogMutation) Where(ps ...predicate.ProjectLog) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectLogMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectLog).
func (m *ProjectLogMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectLogMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.title != nil {
		fields = append(fields, projectlog.FieldTitle)
	}
	if m.author != nil {
		fields = append(fields, projectlog.FieldAuthor)
	}
	if m.content != nil {
		fields = append(fields, projectlog.FieldContent)
	}
	if m.start_date != nil {
		fields = append(fields, projectlog.FieldStartDate)
	}
	if m.end_date != nil {
		fields = append(fields, projectlog.FieldEndDate)
	}
	if m.created_at != nil {
		fields = append(fields, projectlog.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectLogMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectlog.FieldTitle:
		return m.Title()
	case projectlog.FieldAuthor:
		return m.Author()
	case projectlog.FieldContent:
		return m.Content()
	case projectlog.FieldStartDate:
		return m.StartDate()
	case projectlog.FieldEndDate:
		return m.EndDate()
	case projectlog.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectLogMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectlog.FieldTitle:
		return m.OldTitle(ctx)
	case projectlog.FieldAuthor:
		return m.OldAuthor(ctx)
	case projectlog.FieldContent:
		return m.OldContent(ctx)
	case projectlog.FieldStartDate:
		return m.OldStartDate(ctx)
	case projectlog.FieldEndDate:
		return m.OldEndDate(ctx)
	case projectlog.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectLog field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectlog.FieldTitle:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTitle(v)
		return nil
	case projectlog.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case projectlog.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	case projectlog.FieldStartDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStartDate(v)
		return nil
	case projectlog.FieldEndDate:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEndDate(v)
		return nil
	case projectlog.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectLog field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectLogMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectLogMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectLog numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectLogMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(projectlog.FieldCreatedAt) {
		fields = append(fields, projectlog.FieldCreatedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectLogMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectLogMutation) ClearField(name string) error {
	switch name {
	case projectlog.FieldCreatedAt:
		m.ClearCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectLog nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectLogMutation) ResetField(name string) error {
	switch name {
	case projectlog.FieldTitle:
		m.ResetTitle()
		return nil
	case projectlog.FieldAuthor:
		m.ResetAuthor()
		return nil
	case projectlog.FieldContent:
		m.ResetContent()
		return nil
	case projectlog.FieldStartDate:
		m.ResetStartDate()
		return nil
	case projectlog.FieldEndDate:
		m.ResetEndDate()
		return nil
	case projectlog.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown ProjectLog field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectLogMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.project != nil {
		edges = append(edges, projectlog.EdgeProject)
	}
	if m.project_club != nil {
		edges = append(edges, projectlog.EdgeProjectClub)
	}
	if m.project_log_participant != nil {
		edges = append(edges, projectlog.EdgeProjectLogParticipant)
	}
	if m.project_log_feedback != nil {
		edges = append(edges, projectlog.EdgeProjectLogFeedback)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectLogMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectlog.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	case projectlog.EdgeProjectClub:
		if id := m.project_club; id != nil {
			return []ent.Value{*id}
		}
	case projectlog.EdgeProjectLogParticipant:
		ids := make([]ent.Value, 0, len(m.project_log_participant))
		for id := range m.project_log_participant {
			ids = append(ids, id)
		}
		return ids
	case projectlog.EdgeProjectLogFeedback:
		ids := make([]ent.Value, 0, len(m.project_log_feedback))
		for id := range m.project_log_feedback {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectLogMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedproject_log_participant != nil {
		edges = append(edges, projectlog.EdgeProjectLogParticipant)
	}
	if m.removedproject_log_feedback != nil {
		edges = append(edges, projectlog.EdgeProjectLogFeedback)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectLogMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case projectlog.EdgeProjectLogParticipant:
		ids := make([]ent.Value, 0, len(m.removedproject_log_participant))
		for id := range m.removedproject_log_participant {
			ids = append(ids, id)
		}
		return ids
	case projectlog.EdgeProjectLogFeedback:
		ids := make([]ent.Value, 0, len(m.removedproject_log_feedback))
		for id := range m.removedproject_log_feedback {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectLogMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedproject {
		edges = append(edges, projectlog.EdgeProject)
	}
	if m.clearedproject_club {
		edges = append(edges, projectlog.EdgeProjectClub)
	}
	if m.clearedproject_log_participant {
		edges = append(edges, projectlog.EdgeProjectLogParticipant)
	}
	if m.clearedproject_log_feedback {
		edges = append(edges, projectlog.EdgeProjectLogFeedback)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectLogMutation) EdgeCleared(name string) bool {
	switch name {
	case projectlog.EdgeProject:
		return m.clearedproject
	case projectlog.EdgeProjectClub:
		return m.clearedproject_club
	case projectlog.EdgeProjectLogParticipant:
		return m.clearedproject_log_participant
	case projectlog.EdgeProjectLogFeedback:
		return m.clearedproject_log_feedback
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectLogMutation) ClearEdge(name string) error {
	switch name {
	case projectlog.EdgeProject:
		m.ClearProject()
		return nil
	case projectlog.EdgeProjectClub:
		m.ClearProjectClub()
		return nil
	}
	return fmt.Errorf("unknown ProjectLog unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectLogMutation) ResetEdge(name string) error {
	switch name {
	case projectlog.EdgeProject:
		m.ResetProject()
		return nil
	case projectlog.EdgeProjectClub:
		m.ResetProjectClub()
		return nil
	case projectlog.EdgeProjectLogParticipant:
		m.ResetProjectLogParticipant()
		return nil
	case projectlog.EdgeProjectLogFeedback:
		m.ResetProjectLogFeedback()
		return nil
	}
	return fmt.Errorf("unknown ProjectLog edge %s", name)
}

// ProjectLogFeedbackMutation represents an operation that mutates the ProjectLogFeedback nodes in the graph.
type ProjectLogFeedbackMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	author             *string
	content            *string
	clearedFields      map[string]struct{}
	project_log        *int
	clearedproject_log bool
	done               bool
	oldValue           func(context.Context) (*ProjectLogFeedback, error)
	predicates         []predicate.ProjectLogFeedback
}

var _ ent.Mutation = (*ProjectLogFeedbackMutation)(nil)

// projectlogfeedbackOption allows management of the mutation configuration using functional options.
type projectlogfeedbackOption func(*ProjectLogFeedbackMutation)

// newProjectLogFeedbackMutation creates new mutation for the ProjectLogFeedback entity.
func newProjectLogFeedbackMutation(c config, op Op, opts ...projectlogfeedbackOption) *ProjectLogFeedbackMutation {
	m := &ProjectLogFeedbackMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectLogFeedback,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectLogFeedbackID sets the ID field of the mutation.
func withProjectLogFeedbackID(id int) projectlogfeedbackOption {
	return func(m *ProjectLogFeedbackMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectLogFeedback
		)
		m.oldValue = func(ctx context.Context) (*ProjectLogFeedback, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectLogFeedback.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectLogFeedback sets the old ProjectLogFeedback of the mutation.
func withProjectLogFeedback(node *ProjectLogFeedback) projectlogfeedbackOption {
	return func(m *ProjectLogFeedbackMutation) {
		m.oldValue = func(context.Context) (*ProjectLogFeedback, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectLogFeedbackMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectLogFeedbackMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectLogFeedbackMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetAuthor sets the "author" field.
func (m *ProjectLogFeedbackMutation) SetAuthor(s string) {
	m.author = &s
}

// Author returns the value of the "author" field in the mutation.
func (m *ProjectLogFeedbackMutation) Author() (r string, exists bool) {
	v := m.author
	if v == nil {
		return
	}
	return *v, true
}

// OldAuthor returns the old "author" field's value of the ProjectLogFeedback entity.
// If the ProjectLogFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogFeedbackMutation) OldAuthor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAuthor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAuthor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAuthor: %w", err)
	}
	return oldValue.Author, nil
}

// ResetAuthor resets all changes to the "author" field.
func (m *ProjectLogFeedbackMutation) ResetAuthor() {
	m.author = nil
}

// SetContent sets the "content" field.
func (m *ProjectLogFeedbackMutation) SetContent(s string) {
	m.content = &s
}

// Content returns the value of the "content" field in the mutation.
func (m *ProjectLogFeedbackMutation) Content() (r string, exists bool) {
	v := m.content
	if v == nil {
		return
	}
	return *v, true
}

// OldContent returns the old "content" field's value of the ProjectLogFeedback entity.
// If the ProjectLogFeedback object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogFeedbackMutation) OldContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldContent: %w", err)
	}
	return oldValue.Content, nil
}

// ResetContent resets all changes to the "content" field.
func (m *ProjectLogFeedbackMutation) ResetContent() {
	m.content = nil
}

// SetProjectLogID sets the "project_log" edge to the ProjectLog entity by id.
func (m *ProjectLogFeedbackMutation) SetProjectLogID(id int) {
	m.project_log = &id
}

// ClearProjectLog clears the "project_log" edge to the ProjectLog entity.
func (m *ProjectLogFeedbackMutation) ClearProjectLog() {
	m.clearedproject_log = true
}

// ProjectLogCleared reports if the "project_log" edge to the ProjectLog entity was cleared.
func (m *ProjectLogFeedbackMutation) ProjectLogCleared() bool {
	return m.clearedproject_log
}

// ProjectLogID returns the "project_log" edge ID in the mutation.
func (m *ProjectLogFeedbackMutation) ProjectLogID() (id int, exists bool) {
	if m.project_log != nil {
		return *m.project_log, true
	}
	return
}

// ProjectLogIDs returns the "project_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectLogID instead. It exists only for internal usage by the builders.
func (m *ProjectLogFeedbackMutation) ProjectLogIDs() (ids []int) {
	if id := m.project_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectLog resets all changes to the "project_log" edge.
func (m *ProjectLogFeedbackMutation) ResetProjectLog() {
	m.project_log = nil
	m.clearedproject_log = false
}

// Where appends a list predicates to the ProjectLogFeedbackMutation builder.
func (m *ProjectLogFeedbackMutation) Where(ps ...predicate.ProjectLogFeedback) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectLogFeedbackMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectLogFeedback).
func (m *ProjectLogFeedbackMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectLogFeedbackMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.author != nil {
		fields = append(fields, projectlogfeedback.FieldAuthor)
	}
	if m.content != nil {
		fields = append(fields, projectlogfeedback.FieldContent)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectLogFeedbackMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectlogfeedback.FieldAuthor:
		return m.Author()
	case projectlogfeedback.FieldContent:
		return m.Content()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectLogFeedbackMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectlogfeedback.FieldAuthor:
		return m.OldAuthor(ctx)
	case projectlogfeedback.FieldContent:
		return m.OldContent(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectLogFeedback field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogFeedbackMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectlogfeedback.FieldAuthor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAuthor(v)
		return nil
	case projectlogfeedback.FieldContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetContent(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectLogFeedback field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectLogFeedbackMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectLogFeedbackMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogFeedbackMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectLogFeedback numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectLogFeedbackMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectLogFeedbackMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectLogFeedbackMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectLogFeedback nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectLogFeedbackMutation) ResetField(name string) error {
	switch name {
	case projectlogfeedback.FieldAuthor:
		m.ResetAuthor()
		return nil
	case projectlogfeedback.FieldContent:
		m.ResetContent()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogFeedback field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectLogFeedbackMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project_log != nil {
		edges = append(edges, projectlogfeedback.EdgeProjectLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectLogFeedbackMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectlogfeedback.EdgeProjectLog:
		if id := m.project_log; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectLogFeedbackMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectLogFeedbackMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectLogFeedbackMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject_log {
		edges = append(edges, projectlogfeedback.EdgeProjectLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectLogFeedbackMutation) EdgeCleared(name string) bool {
	switch name {
	case projectlogfeedback.EdgeProjectLog:
		return m.clearedproject_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectLogFeedbackMutation) ClearEdge(name string) error {
	switch name {
	case projectlogfeedback.EdgeProjectLog:
		m.ClearProjectLog()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogFeedback unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectLogFeedbackMutation) ResetEdge(name string) error {
	switch name {
	case projectlogfeedback.EdgeProjectLog:
		m.ResetProjectLog()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogFeedback edge %s", name)
}

// ProjectLogParticipantMutation represents an operation that mutates the ProjectLogParticipant nodes in the graph.
type ProjectLogParticipantMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	clearedFields      map[string]struct{}
	project_log        *int
	clearedproject_log bool
	done               bool
	oldValue           func(context.Context) (*ProjectLogParticipant, error)
	predicates         []predicate.ProjectLogParticipant
}

var _ ent.Mutation = (*ProjectLogParticipantMutation)(nil)

// projectlogparticipantOption allows management of the mutation configuration using functional options.
type projectlogparticipantOption func(*ProjectLogParticipantMutation)

// newProjectLogParticipantMutation creates new mutation for the ProjectLogParticipant entity.
func newProjectLogParticipantMutation(c config, op Op, opts ...projectlogparticipantOption) *ProjectLogParticipantMutation {
	m := &ProjectLogParticipantMutation{
		config:        c,
		op:            op,
		typ:           TypeProjectLogParticipant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withProjectLogParticipantID sets the ID field of the mutation.
func withProjectLogParticipantID(id int) projectlogparticipantOption {
	return func(m *ProjectLogParticipantMutation) {
		var (
			err   error
			once  sync.Once
			value *ProjectLogParticipant
		)
		m.oldValue = func(ctx context.Context) (*ProjectLogParticipant, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ProjectLogParticipant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProjectLogParticipant sets the old ProjectLogParticipant of the mutation.
func withProjectLogParticipant(node *ProjectLogParticipant) projectlogparticipantOption {
	return func(m *ProjectLogParticipantMutation) {
		m.oldValue = func(context.Context) (*ProjectLogParticipant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ProjectLogParticipantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ProjectLogParticipantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ProjectLogParticipantMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ProjectLogParticipantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ProjectLogParticipantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the ProjectLogParticipant entity.
// If the ProjectLogParticipant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ProjectLogParticipantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ProjectLogParticipantMutation) ResetName() {
	m.name = nil
}

// SetProjectLogID sets the "project_log" edge to the ProjectLog entity by id.
func (m *ProjectLogParticipantMutation) SetProjectLogID(id int) {
	m.project_log = &id
}

// ClearProjectLog clears the "project_log" edge to the ProjectLog entity.
func (m *ProjectLogParticipantMutation) ClearProjectLog() {
	m.clearedproject_log = true
}

// ProjectLogCleared reports if the "project_log" edge to the ProjectLog entity was cleared.
func (m *ProjectLogParticipantMutation) ProjectLogCleared() bool {
	return m.clearedproject_log
}

// ProjectLogID returns the "project_log" edge ID in the mutation.
func (m *ProjectLogParticipantMutation) ProjectLogID() (id int, exists bool) {
	if m.project_log != nil {
		return *m.project_log, true
	}
	return
}

// ProjectLogIDs returns the "project_log" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectLogID instead. It exists only for internal usage by the builders.
func (m *ProjectLogParticipantMutation) ProjectLogIDs() (ids []int) {
	if id := m.project_log; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProjectLog resets all changes to the "project_log" edge.
func (m *ProjectLogParticipantMutation) ResetProjectLog() {
	m.project_log = nil
	m.clearedproject_log = false
}

// Where appends a list predicates to the ProjectLogParticipantMutation builder.
func (m *ProjectLogParticipantMutation) Where(ps ...predicate.ProjectLogParticipant) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ProjectLogParticipantMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ProjectLogParticipant).
func (m *ProjectLogParticipantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ProjectLogParticipantMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.name != nil {
		fields = append(fields, projectlogparticipant.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ProjectLogParticipantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case projectlogparticipant.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ProjectLogParticipantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case projectlogparticipant.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown ProjectLogParticipant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogParticipantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case projectlogparticipant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown ProjectLogParticipant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ProjectLogParticipantMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ProjectLogParticipantMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ProjectLogParticipantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ProjectLogParticipant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ProjectLogParticipantMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ProjectLogParticipantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ProjectLogParticipantMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ProjectLogParticipant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ProjectLogParticipantMutation) ResetField(name string) error {
	switch name {
	case projectlogparticipant.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogParticipant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ProjectLogParticipantMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.project_log != nil {
		edges = append(edges, projectlogparticipant.EdgeProjectLog)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ProjectLogParticipantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case projectlogparticipant.EdgeProjectLog:
		if id := m.project_log; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ProjectLogParticipantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ProjectLogParticipantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ProjectLogParticipantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedproject_log {
		edges = append(edges, projectlogparticipant.EdgeProjectLog)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ProjectLogParticipantMutation) EdgeCleared(name string) bool {
	switch name {
	case projectlogparticipant.EdgeProjectLog:
		return m.clearedproject_log
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ProjectLogParticipantMutation) ClearEdge(name string) error {
	switch name {
	case projectlogparticipant.EdgeProjectLog:
		m.ClearProjectLog()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogParticipant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ProjectLogParticipantMutation) ResetEdge(name string) error {
	switch name {
	case projectlogparticipant.EdgeProjectLog:
		m.ResetProjectLog()
		return nil
	}
	return fmt.Errorf("unknown ProjectLogParticipant edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	university         *string
	description        *string
	profile_link       *string
	profile_image      *string
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	club               map[int]struct{}
	removedclub        map[int]struct{}
	clearedclub        bool
	club_member        map[int]struct{}
	removedclub_member map[int]struct{}
	clearedclub_member bool
	task_type          map[int]struct{}
	removedtask_type   map[int]struct{}
	clearedtask_type   bool
	done               bool
	oldValue           func(context.Context) (*Student, error)
	predicates         []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id int) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *StudentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudentMutation) ResetName() {
	m.name = nil
}

// SetUniversity sets the "university" field.
func (m *StudentMutation) SetUniversity(s string) {
	m.university = &s
}

// University returns the value of the "university" field in the mutation.
func (m *StudentMutation) University() (r string, exists bool) {
	v := m.university
	if v == nil {
		return
	}
	return *v, true
}

// OldUniversity returns the old "university" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUniversity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUniversity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUniversity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniversity: %w", err)
	}
	return oldValue.University, nil
}

// ResetUniversity resets all changes to the "university" field.
func (m *StudentMutation) ResetUniversity() {
	m.university = nil
}

// SetDescription sets the "description" field.
func (m *StudentMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *StudentMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *StudentMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[student.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *StudentMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[student.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *StudentMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, student.FieldDescription)
}

// SetProfileLink sets the "profile_link" field.
func (m *StudentMutation) SetProfileLink(s string) {
	m.profile_link = &s
}

// ProfileLink returns the value of the "profile_link" field in the mutation.
func (m *StudentMutation) ProfileLink() (r string, exists bool) {
	v := m.profile_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileLink returns the old "profile_link" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldProfileLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileLink: %w", err)
	}
	return oldValue.ProfileLink, nil
}

// ClearProfileLink clears the value of the "profile_link" field.
func (m *StudentMutation) ClearProfileLink() {
	m.profile_link = nil
	m.clearedFields[student.FieldProfileLink] = struct{}{}
}

// ProfileLinkCleared returns if the "profile_link" field was cleared in this mutation.
func (m *StudentMutation) ProfileLinkCleared() bool {
	_, ok := m.clearedFields[student.FieldProfileLink]
	return ok
}

// ResetProfileLink resets all changes to the "profile_link" field.
func (m *StudentMutation) ResetProfileLink() {
	m.profile_link = nil
	delete(m.clearedFields, student.FieldProfileLink)
}

// SetProfileImage sets the "profile_image" field.
func (m *StudentMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *StudentMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *StudentMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[student.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *StudentMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[student.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *StudentMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, student.FieldProfileImage)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddClubIDs adds the "club" edge to the Club entity by ids.
func (m *StudentMutation) AddClubIDs(ids ...int) {
	if m.club == nil {
		m.club = make(map[int]struct{})
	}
	for i := range ids {
		m.club[ids[i]] = struct{}{}
	}
}

// ClearClub clears the "club" edge to the Club entity.
func (m *StudentMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *StudentMutation) ClubCleared() bool {
	return m.clearedclub
}

// RemoveClubIDs removes the "club" edge to the Club entity by IDs.
func (m *StudentMutation) RemoveClubIDs(ids ...int) {
	if m.removedclub == nil {
		m.removedclub = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club, ids[i])
		m.removedclub[ids[i]] = struct{}{}
	}
}

// RemovedClub returns the removed IDs of the "club" edge to the Club entity.
func (m *StudentMutation) RemovedClubIDs() (ids []int) {
	for id := range m.removedclub {
		ids = append(ids, id)
	}
	return
}

// ClubIDs returns the "club" edge IDs in the mutation.
func (m *StudentMutation) ClubIDs() (ids []int) {
	for id := range m.club {
		ids = append(ids, id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *StudentMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
	m.removedclub = nil
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *StudentMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *StudentMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *StudentMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *StudentMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *StudentMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *StudentMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *StudentMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// AddTaskTypeIDs adds the "task_type" edge to the TaskType entity by ids.
func (m *StudentMutation) AddTaskTypeIDs(ids ...int) {
	if m.task_type == nil {
		m.task_type = make(map[int]struct{})
	}
	for i := range ids {
		m.task_type[ids[i]] = struct{}{}
	}
}

// ClearTaskType clears the "task_type" edge to the TaskType entity.
func (m *StudentMutation) ClearTaskType() {
	m.clearedtask_type = true
}

// TaskTypeCleared reports if the "task_type" edge to the TaskType entity was cleared.
func (m *StudentMutation) TaskTypeCleared() bool {
	return m.clearedtask_type
}

// RemoveTaskTypeIDs removes the "task_type" edge to the TaskType entity by IDs.
func (m *StudentMutation) RemoveTaskTypeIDs(ids ...int) {
	if m.removedtask_type == nil {
		m.removedtask_type = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.task_type, ids[i])
		m.removedtask_type[ids[i]] = struct{}{}
	}
}

// RemovedTaskType returns the removed IDs of the "task_type" edge to the TaskType entity.
func (m *StudentMutation) RemovedTaskTypeIDs() (ids []int) {
	for id := range m.removedtask_type {
		ids = append(ids, id)
	}
	return
}

// TaskTypeIDs returns the "task_type" edge IDs in the mutation.
func (m *StudentMutation) TaskTypeIDs() (ids []int) {
	for id := range m.task_type {
		ids = append(ids, id)
	}
	return
}

// ResetTaskType resets all changes to the "task_type" edge.
func (m *StudentMutation) ResetTaskType() {
	m.task_type = nil
	m.clearedtask_type = false
	m.removedtask_type = nil
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.name != nil {
		fields = append(fields, student.FieldName)
	}
	if m.university != nil {
		fields = append(fields, student.FieldUniversity)
	}
	if m.description != nil {
		fields = append(fields, student.FieldDescription)
	}
	if m.profile_link != nil {
		fields = append(fields, student.FieldProfileLink)
	}
	if m.profile_image != nil {
		fields = append(fields, student.FieldProfileImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldName:
		return m.Name()
	case student.FieldUniversity:
		return m.University()
	case student.FieldDescription:
		return m.Description()
	case student.FieldProfileLink:
		return m.ProfileLink()
	case student.FieldProfileImage:
		return m.ProfileImage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldName:
		return m.OldName(ctx)
	case student.FieldUniversity:
		return m.OldUniversity(ctx)
	case student.FieldDescription:
		return m.OldDescription(ctx)
	case student.FieldProfileLink:
		return m.OldProfileLink(ctx)
	case student.FieldProfileImage:
		return m.OldProfileImage(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case student.FieldUniversity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniversity(v)
		return nil
	case student.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case student.FieldProfileLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileLink(v)
		return nil
	case student.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(student.FieldDescription) {
		fields = append(fields, student.FieldDescription)
	}
	if m.FieldCleared(student.FieldProfileLink) {
		fields = append(fields, student.FieldProfileLink)
	}
	if m.FieldCleared(student.FieldProfileImage) {
		fields = append(fields, student.FieldProfileImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	switch name {
	case student.FieldDescription:
		m.ClearDescription()
		return nil
	case student.FieldProfileLink:
		m.ClearProfileLink()
		return nil
	case student.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	}
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldName:
		m.ResetName()
		return nil
	case student.FieldUniversity:
		m.ResetUniversity()
		return nil
	case student.FieldDescription:
		m.ResetDescription()
		return nil
	case student.FieldProfileLink:
		m.ResetProfileLink()
		return nil
	case student.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	if m.club != nil {
		edges = append(edges, student.EdgeClub)
	}
	if m.club_member != nil {
		edges = append(edges, student.EdgeClubMember)
	}
	if m.task_type != nil {
		edges = append(edges, student.EdgeTaskType)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeClub:
		ids := make([]ent.Value, 0, len(m.club))
		for id := range m.club {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.task_type))
		for id := range m.task_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedclub != nil {
		edges = append(edges, student.EdgeClub)
	}
	if m.removedclub_member != nil {
		edges = append(edges, student.EdgeClubMember)
	}
	if m.removedtask_type != nil {
		edges = append(edges, student.EdgeTaskType)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeClub:
		ids := make([]ent.Value, 0, len(m.removedclub))
		for id := range m.removedclub {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeTaskType:
		ids := make([]ent.Value, 0, len(m.removedtask_type))
		for id := range m.removedtask_type {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	if m.clearedclub {
		edges = append(edges, student.EdgeClub)
	}
	if m.clearedclub_member {
		edges = append(edges, student.EdgeClubMember)
	}
	if m.clearedtask_type {
		edges = append(edges, student.EdgeTaskType)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeUser:
		return m.cleareduser
	case student.EdgeClub:
		return m.clearedclub
	case student.EdgeClubMember:
		return m.clearedclub_member
	case student.EdgeTaskType:
		return m.clearedtask_type
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ResetUser()
		return nil
	case student.EdgeClub:
		m.ResetClub()
		return nil
	case student.EdgeClubMember:
		m.ResetClubMember()
		return nil
	case student.EdgeTaskType:
		m.ResetTaskType()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// TaskTypeMutation represents an operation that mutates the TaskType nodes in the graph.
type TaskTypeMutation struct {
	config
	op             Op
	typ            string
	id             *int
	_type          *string
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	club           *int
	clearedclub    bool
	company        *int
	clearedcompany bool
	project        *int
	clearedproject bool
	done           bool
	oldValue       func(context.Context) (*TaskType, error)
	predicates     []predicate.TaskType
}

var _ ent.Mutation = (*TaskTypeMutation)(nil)

// tasktypeOption allows management of the mutation configuration using functional options.
type tasktypeOption func(*TaskTypeMutation)

// newTaskTypeMutation creates new mutation for the TaskType entity.
func newTaskTypeMutation(c config, op Op, opts ...tasktypeOption) *TaskTypeMutation {
	m := &TaskTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeTaskType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTaskTypeID sets the ID field of the mutation.
func withTaskTypeID(id int) tasktypeOption {
	return func(m *TaskTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *TaskType
		)
		m.oldValue = func(ctx context.Context) (*TaskType, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TaskType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTaskType sets the old TaskType of the mutation.
func withTaskType(node *TaskType) tasktypeOption {
	return func(m *TaskTypeMutation) {
		m.oldValue = func(context.Context) (*TaskType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TaskTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TaskTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TaskTypeMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetType sets the "type" field.
func (m *TaskTypeMutation) SetType(s string) {
	m._type = &s
}

// GetType returns the value of the "type" field in the mutation.
func (m *TaskTypeMutation) GetType() (r string, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the TaskType entity.
// If the TaskType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TaskTypeMutation) OldType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TaskTypeMutation) ResetType() {
	m._type = nil
}

// SetStudentID sets the "student" edge to the Student entity by id.
func (m *TaskTypeMutation) SetStudentID(id int) {
	m.student = &id
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *TaskTypeMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *TaskTypeMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentID returns the "student" edge ID in the mutation.
func (m *TaskTypeMutation) StudentID() (id int, exists bool) {
	if m.student != nil {
		return *m.student, true
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *TaskTypeMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *TaskTypeMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// SetClubID sets the "club" edge to the Club entity by id.
func (m *TaskTypeMutation) SetClubID(id int) {
	m.club = &id
}

// ClearClub clears the "club" edge to the Club entity.
func (m *TaskTypeMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *TaskTypeMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubID returns the "club" edge ID in the mutation.
func (m *TaskTypeMutation) ClubID() (id int, exists bool) {
	if m.club != nil {
		return *m.club, true
	}
	return
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *TaskTypeMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *TaskTypeMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// SetCompanyID sets the "company" edge to the Company entity by id.
func (m *TaskTypeMutation) SetCompanyID(id int) {
	m.company = &id
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *TaskTypeMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *TaskTypeMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// CompanyID returns the "company" edge ID in the mutation.
func (m *TaskTypeMutation) CompanyID() (id int, exists bool) {
	if m.company != nil {
		return *m.company, true
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CompanyID instead. It exists only for internal usage by the builders.
func (m *TaskTypeMutation) CompanyIDs() (ids []int) {
	if id := m.company; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *TaskTypeMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
}

// SetProjectID sets the "project" edge to the Project entity by id.
func (m *TaskTypeMutation) SetProjectID(id int) {
	m.project = &id
}

// ClearProject clears the "project" edge to the Project entity.
func (m *TaskTypeMutation) ClearProject() {
	m.clearedproject = true
}

// ProjectCleared reports if the "project" edge to the Project entity was cleared.
func (m *TaskTypeMutation) ProjectCleared() bool {
	return m.clearedproject
}

// ProjectID returns the "project" edge ID in the mutation.
func (m *TaskTypeMutation) ProjectID() (id int, exists bool) {
	if m.project != nil {
		return *m.project, true
	}
	return
}

// ProjectIDs returns the "project" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ProjectID instead. It exists only for internal usage by the builders.
func (m *TaskTypeMutation) ProjectIDs() (ids []int) {
	if id := m.project; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProject resets all changes to the "project" edge.
func (m *TaskTypeMutation) ResetProject() {
	m.project = nil
	m.clearedproject = false
}

// Where appends a list predicates to the TaskTypeMutation builder.
func (m *TaskTypeMutation) Where(ps ...predicate.TaskType) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *TaskTypeMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (TaskType).
func (m *TaskTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TaskTypeMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._type != nil {
		fields = append(fields, tasktype.FieldType)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TaskTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tasktype.FieldType:
		return m.GetType()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TaskTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tasktype.FieldType:
		return m.OldType(ctx)
	}
	return nil, fmt.Errorf("unknown TaskType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tasktype.FieldType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	}
	return fmt.Errorf("unknown TaskType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TaskTypeMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TaskTypeMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TaskTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TaskType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TaskTypeMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TaskTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TaskTypeMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TaskType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TaskTypeMutation) ResetField(name string) error {
	switch name {
	case tasktype.FieldType:
		m.ResetType()
		return nil
	}
	return fmt.Errorf("unknown TaskType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TaskTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.student != nil {
		edges = append(edges, tasktype.EdgeStudent)
	}
	if m.club != nil {
		edges = append(edges, tasktype.EdgeClub)
	}
	if m.company != nil {
		edges = append(edges, tasktype.EdgeCompany)
	}
	if m.project != nil {
		edges = append(edges, tasktype.EdgeProject)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TaskTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tasktype.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case tasktype.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	case tasktype.EdgeCompany:
		if id := m.company; id != nil {
			return []ent.Value{*id}
		}
	case tasktype.EdgeProject:
		if id := m.project; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TaskTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TaskTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TaskTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedstudent {
		edges = append(edges, tasktype.EdgeStudent)
	}
	if m.clearedclub {
		edges = append(edges, tasktype.EdgeClub)
	}
	if m.clearedcompany {
		edges = append(edges, tasktype.EdgeCompany)
	}
	if m.clearedproject {
		edges = append(edges, tasktype.EdgeProject)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TaskTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case tasktype.EdgeStudent:
		return m.clearedstudent
	case tasktype.EdgeClub:
		return m.clearedclub
	case tasktype.EdgeCompany:
		return m.clearedcompany
	case tasktype.EdgeProject:
		return m.clearedproject
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TaskTypeMutation) ClearEdge(name string) error {
	switch name {
	case tasktype.EdgeStudent:
		m.ClearStudent()
		return nil
	case tasktype.EdgeClub:
		m.ClearClub()
		return nil
	case tasktype.EdgeCompany:
		m.ClearCompany()
		return nil
	case tasktype.EdgeProject:
		m.ClearProject()
		return nil
	}
	return fmt.Errorf("unknown TaskType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TaskTypeMutation) ResetEdge(name string) error {
	switch name {
	case tasktype.EdgeStudent:
		m.ResetStudent()
		return nil
	case tasktype.EdgeClub:
		m.ResetClub()
		return nil
	case tasktype.EdgeCompany:
		m.ResetCompany()
		return nil
	case tasktype.EdgeProject:
		m.ResetProject()
		return nil
	}
	return fmt.Errorf("unknown TaskType edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	email              *string
	password           *string
	kind               *user.Kind
	clearedFields      map[string]struct{}
	student            map[int]struct{}
	removedstudent     map[int]struct{}
	clearedstudent     bool
	company            map[int]struct{}
	removedcompany     map[int]struct{}
	clearedcompany     bool
	club_member        map[int]struct{}
	removedclub_member map[int]struct{}
	clearedclub_member bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetKind sets the "kind" field.
func (m *UserMutation) SetKind(u user.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserMutation) Kind() (r user.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKind(ctx context.Context) (v user.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserMutation) ResetKind() {
	m.kind = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *UserMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *UserMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *UserMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *UserMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// AddCompanyIDs adds the "company" edge to the Company entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// RemoveCompanyIDs removes the "company" edge to the Company entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company, ids[i])
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed IDs of the "company" edge to the Company entity.
func (m *UserMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
func (m *UserMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
	m.removedcompany = nil
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *UserMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *UserMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *UserMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *UserMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *UserMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *UserMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *UserMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.kind != nil {
		fields = append(fields, user.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldKind:
		v, ok := value.(user.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.club_member != nil {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstudent != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.removedcompany != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.removedclub_member != nil {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedclub_member {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStudent:
		return m.clearedstudent
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeClubMember:
		return m.clearedclub_member
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeClubMember:
		m.ResetClubMember()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
