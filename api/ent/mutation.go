// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/Wanted-Linx/linx-backend/api/ent/club"
	"github.com/Wanted-Linx/linx-backend/api/ent/clubmember"
	"github.com/Wanted-Linx/linx-backend/api/ent/company"
	"github.com/Wanted-Linx/linx-backend/api/ent/predicate"
	"github.com/Wanted-Linx/linx-backend/api/ent/student"
	"github.com/Wanted-Linx/linx-backend/api/ent/user"

	"entgo.io/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeClub       = "Club"
	TypeClubMember = "ClubMember"
	TypeCompany    = "Company"
	TypeStudent    = "Student"
	TypeUser       = "User"
)

// ClubMutation represents an operation that mutates the Club nodes in the graph.
type ClubMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	organization       *string
	description        *string
	profile_image      *string
	profile_link       *string
	created_at         *time.Time
	clearedFields      map[string]struct{}
	leader             *int
	clearedleader      bool
	club_member        map[int]struct{}
	removedclub_member map[int]struct{}
	clearedclub_member bool
	done               bool
	oldValue           func(context.Context) (*Club, error)
	predicates         []predicate.Club
}

var _ ent.Mutation = (*ClubMutation)(nil)

// clubOption allows management of the mutation configuration using functional options.
type clubOption func(*ClubMutation)

// newClubMutation creates new mutation for the Club entity.
func newClubMutation(c config, op Op, opts ...clubOption) *ClubMutation {
	m := &ClubMutation{
		config:        c,
		op:            op,
		typ:           TypeClub,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubID sets the ID field of the mutation.
func withClubID(id int) clubOption {
	return func(m *ClubMutation) {
		var (
			err   error
			once  sync.Once
			value *Club
		)
		m.oldValue = func(ctx context.Context) (*Club, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Club.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClub sets the old Club of the mutation.
func withClub(node *Club) clubOption {
	return func(m *ClubMutation) {
		m.oldValue = func(context.Context) (*Club, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *ClubMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *ClubMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *ClubMutation) ResetName() {
	m.name = nil
}

// SetOrganization sets the "organization" field.
func (m *ClubMutation) SetOrganization(s string) {
	m.organization = &s
}

// Organization returns the value of the "organization" field in the mutation.
func (m *ClubMutation) Organization() (r string, exists bool) {
	v := m.organization
	if v == nil {
		return
	}
	return *v, true
}

// OldOrganization returns the old "organization" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldOrganization(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOrganization is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOrganization requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOrganization: %w", err)
	}
	return oldValue.Organization, nil
}

// ResetOrganization resets all changes to the "organization" field.
func (m *ClubMutation) ResetOrganization() {
	m.organization = nil
}

// SetDescription sets the "description" field.
func (m *ClubMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *ClubMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ResetDescription resets all changes to the "description" field.
func (m *ClubMutation) ResetDescription() {
	m.description = nil
}

// SetProfileImage sets the "profile_image" field.
func (m *ClubMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *ClubMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *ClubMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[club.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *ClubMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[club.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *ClubMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, club.FieldProfileImage)
}

// SetProfileLink sets the "profile_link" field.
func (m *ClubMutation) SetProfileLink(s string) {
	m.profile_link = &s
}

// ProfileLink returns the value of the "profile_link" field in the mutation.
func (m *ClubMutation) ProfileLink() (r string, exists bool) {
	v := m.profile_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileLink returns the old "profile_link" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldProfileLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileLink: %w", err)
	}
	return oldValue.ProfileLink, nil
}

// ClearProfileLink clears the value of the "profile_link" field.
func (m *ClubMutation) ClearProfileLink() {
	m.profile_link = nil
	m.clearedFields[club.FieldProfileLink] = struct{}{}
}

// ProfileLinkCleared returns if the "profile_link" field was cleared in this mutation.
func (m *ClubMutation) ProfileLinkCleared() bool {
	_, ok := m.clearedFields[club.FieldProfileLink]
	return ok
}

// ResetProfileLink resets all changes to the "profile_link" field.
func (m *ClubMutation) ResetProfileLink() {
	m.profile_link = nil
	delete(m.clearedFields, club.FieldProfileLink)
}

// SetCreatedAt sets the "created_at" field.
func (m *ClubMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *ClubMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Club entity.
// If the Club object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *ClubMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetLeaderID sets the "leader" edge to the Student entity by id.
func (m *ClubMutation) SetLeaderID(id int) {
	m.leader = &id
}

// ClearLeader clears the "leader" edge to the Student entity.
func (m *ClubMutation) ClearLeader() {
	m.clearedleader = true
}

// LeaderCleared reports if the "leader" edge to the Student entity was cleared.
func (m *ClubMutation) LeaderCleared() bool {
	return m.clearedleader
}

// LeaderID returns the "leader" edge ID in the mutation.
func (m *ClubMutation) LeaderID() (id int, exists bool) {
	if m.leader != nil {
		return *m.leader, true
	}
	return
}

// LeaderIDs returns the "leader" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// LeaderID instead. It exists only for internal usage by the builders.
func (m *ClubMutation) LeaderIDs() (ids []int) {
	if id := m.leader; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetLeader resets all changes to the "leader" edge.
func (m *ClubMutation) ResetLeader() {
	m.leader = nil
	m.clearedleader = false
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *ClubMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *ClubMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *ClubMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *ClubMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *ClubMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *ClubMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *ClubMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// Where appends a list predicates to the ClubMutation builder.
func (m *ClubMutation) Where(ps ...predicate.Club) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClubMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Club).
func (m *ClubMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, club.FieldName)
	}
	if m.organization != nil {
		fields = append(fields, club.FieldOrganization)
	}
	if m.description != nil {
		fields = append(fields, club.FieldDescription)
	}
	if m.profile_image != nil {
		fields = append(fields, club.FieldProfileImage)
	}
	if m.profile_link != nil {
		fields = append(fields, club.FieldProfileLink)
	}
	if m.created_at != nil {
		fields = append(fields, club.FieldCreatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case club.FieldName:
		return m.Name()
	case club.FieldOrganization:
		return m.Organization()
	case club.FieldDescription:
		return m.Description()
	case club.FieldProfileImage:
		return m.ProfileImage()
	case club.FieldProfileLink:
		return m.ProfileLink()
	case club.FieldCreatedAt:
		return m.CreatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case club.FieldName:
		return m.OldName(ctx)
	case club.FieldOrganization:
		return m.OldOrganization(ctx)
	case club.FieldDescription:
		return m.OldDescription(ctx)
	case club.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case club.FieldProfileLink:
		return m.OldProfileLink(ctx)
	case club.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Club field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) SetField(name string, value ent.Value) error {
	switch name {
	case club.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case club.FieldOrganization:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOrganization(v)
		return nil
	case club.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case club.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case club.FieldProfileLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileLink(v)
		return nil
	case club.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Club numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(club.FieldProfileImage) {
		fields = append(fields, club.FieldProfileImage)
	}
	if m.FieldCleared(club.FieldProfileLink) {
		fields = append(fields, club.FieldProfileLink)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMutation) ClearField(name string) error {
	switch name {
	case club.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	case club.FieldProfileLink:
		m.ClearProfileLink()
		return nil
	}
	return fmt.Errorf("unknown Club nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMutation) ResetField(name string) error {
	switch name {
	case club.FieldName:
		m.ResetName()
		return nil
	case club.FieldOrganization:
		m.ResetOrganization()
		return nil
	case club.FieldDescription:
		m.ResetDescription()
		return nil
	case club.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case club.FieldProfileLink:
		m.ResetProfileLink()
		return nil
	case club.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	}
	return fmt.Errorf("unknown Club field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.leader != nil {
		edges = append(edges, club.EdgeLeader)
	}
	if m.club_member != nil {
		edges = append(edges, club.EdgeClubMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeLeader:
		if id := m.leader; id != nil {
			return []ent.Value{*id}
		}
	case club.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedclub_member != nil {
		edges = append(edges, club.EdgeClubMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case club.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedleader {
		edges = append(edges, club.EdgeLeader)
	}
	if m.clearedclub_member {
		edges = append(edges, club.EdgeClubMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMutation) EdgeCleared(name string) bool {
	switch name {
	case club.EdgeLeader:
		return m.clearedleader
	case club.EdgeClubMember:
		return m.clearedclub_member
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMutation) ClearEdge(name string) error {
	switch name {
	case club.EdgeLeader:
		m.ClearLeader()
		return nil
	}
	return fmt.Errorf("unknown Club unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMutation) ResetEdge(name string) error {
	switch name {
	case club.EdgeLeader:
		m.ResetLeader()
		return nil
	case club.EdgeClubMember:
		m.ResetClubMember()
		return nil
	}
	return fmt.Errorf("unknown Club edge %s", name)
}

// ClubMemberMutation represents an operation that mutates the ClubMember nodes in the graph.
type ClubMemberMutation struct {
	config
	op             Op
	typ            string
	id             *int
	clearedFields  map[string]struct{}
	student        *int
	clearedstudent bool
	club           *int
	clearedclub    bool
	done           bool
	oldValue       func(context.Context) (*ClubMember, error)
	predicates     []predicate.ClubMember
}

var _ ent.Mutation = (*ClubMemberMutation)(nil)

// clubmemberOption allows management of the mutation configuration using functional options.
type clubmemberOption func(*ClubMemberMutation)

// newClubMemberMutation creates new mutation for the ClubMember entity.
func newClubMemberMutation(c config, op Op, opts ...clubmemberOption) *ClubMemberMutation {
	m := &ClubMemberMutation{
		config:        c,
		op:            op,
		typ:           TypeClubMember,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withClubMemberID sets the ID field of the mutation.
func withClubMemberID(id int) clubmemberOption {
	return func(m *ClubMemberMutation) {
		var (
			err   error
			once  sync.Once
			value *ClubMember
		)
		m.oldValue = func(ctx context.Context) (*ClubMember, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().ClubMember.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withClubMember sets the old ClubMember of the mutation.
func withClubMember(node *ClubMember) clubmemberOption {
	return func(m *ClubMemberMutation) {
		m.oldValue = func(context.Context) (*ClubMember, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m ClubMemberMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m ClubMemberMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *ClubMemberMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetClubID sets the "club_id" field.
func (m *ClubMemberMutation) SetClubID(i int) {
	m.club = &i
}

// ClubID returns the value of the "club_id" field in the mutation.
func (m *ClubMemberMutation) ClubID() (r int, exists bool) {
	v := m.club
	if v == nil {
		return
	}
	return *v, true
}

// OldClubID returns the old "club_id" field's value of the ClubMember entity.
// If the ClubMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMemberMutation) OldClubID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldClubID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldClubID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldClubID: %w", err)
	}
	return oldValue.ClubID, nil
}

// ResetClubID resets all changes to the "club_id" field.
func (m *ClubMemberMutation) ResetClubID() {
	m.club = nil
}

// SetStudentID sets the "student_id" field.
func (m *ClubMemberMutation) SetStudentID(i int) {
	m.student = &i
}

// StudentID returns the value of the "student_id" field in the mutation.
func (m *ClubMemberMutation) StudentID() (r int, exists bool) {
	v := m.student
	if v == nil {
		return
	}
	return *v, true
}

// OldStudentID returns the old "student_id" field's value of the ClubMember entity.
// If the ClubMember object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *ClubMemberMutation) OldStudentID(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldStudentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldStudentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStudentID: %w", err)
	}
	return oldValue.StudentID, nil
}

// ResetStudentID resets all changes to the "student_id" field.
func (m *ClubMemberMutation) ResetStudentID() {
	m.student = nil
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *ClubMemberMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *ClubMemberMutation) StudentCleared() bool {
	return m.clearedstudent
}

// StudentIDs returns the "student" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// StudentID instead. It exists only for internal usage by the builders.
func (m *ClubMemberMutation) StudentIDs() (ids []int) {
	if id := m.student; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *ClubMemberMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
}

// ClearClub clears the "club" edge to the Club entity.
func (m *ClubMemberMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *ClubMemberMutation) ClubCleared() bool {
	return m.clearedclub
}

// ClubIDs returns the "club" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ClubID instead. It exists only for internal usage by the builders.
func (m *ClubMemberMutation) ClubIDs() (ids []int) {
	if id := m.club; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *ClubMemberMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
}

// Where appends a list predicates to the ClubMemberMutation builder.
func (m *ClubMemberMutation) Where(ps ...predicate.ClubMember) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *ClubMemberMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (ClubMember).
func (m *ClubMemberMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *ClubMemberMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.club != nil {
		fields = append(fields, clubmember.FieldClubID)
	}
	if m.student != nil {
		fields = append(fields, clubmember.FieldStudentID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *ClubMemberMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case clubmember.FieldClubID:
		return m.ClubID()
	case clubmember.FieldStudentID:
		return m.StudentID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *ClubMemberMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case clubmember.FieldClubID:
		return m.OldClubID(ctx)
	case clubmember.FieldStudentID:
		return m.OldStudentID(ctx)
	}
	return nil, fmt.Errorf("unknown ClubMember field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMemberMutation) SetField(name string, value ent.Value) error {
	switch name {
	case clubmember.FieldClubID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetClubID(v)
		return nil
	case clubmember.FieldStudentID:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStudentID(v)
		return nil
	}
	return fmt.Errorf("unknown ClubMember field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *ClubMemberMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *ClubMemberMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *ClubMemberMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown ClubMember numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *ClubMemberMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *ClubMemberMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *ClubMemberMutation) ClearField(name string) error {
	return fmt.Errorf("unknown ClubMember nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *ClubMemberMutation) ResetField(name string) error {
	switch name {
	case clubmember.FieldClubID:
		m.ResetClubID()
		return nil
	case clubmember.FieldStudentID:
		m.ResetStudentID()
		return nil
	}
	return fmt.Errorf("unknown ClubMember field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *ClubMemberMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.student != nil {
		edges = append(edges, clubmember.EdgeStudent)
	}
	if m.club != nil {
		edges = append(edges, clubmember.EdgeClub)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *ClubMemberMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case clubmember.EdgeStudent:
		if id := m.student; id != nil {
			return []ent.Value{*id}
		}
	case clubmember.EdgeClub:
		if id := m.club; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *ClubMemberMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *ClubMemberMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *ClubMemberMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedstudent {
		edges = append(edges, clubmember.EdgeStudent)
	}
	if m.clearedclub {
		edges = append(edges, clubmember.EdgeClub)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *ClubMemberMutation) EdgeCleared(name string) bool {
	switch name {
	case clubmember.EdgeStudent:
		return m.clearedstudent
	case clubmember.EdgeClub:
		return m.clearedclub
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *ClubMemberMutation) ClearEdge(name string) error {
	switch name {
	case clubmember.EdgeStudent:
		m.ClearStudent()
		return nil
	case clubmember.EdgeClub:
		m.ClearClub()
		return nil
	}
	return fmt.Errorf("unknown ClubMember unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *ClubMemberMutation) ResetEdge(name string) error {
	switch name {
	case clubmember.EdgeStudent:
		m.ResetStudent()
		return nil
	case clubmember.EdgeClub:
		m.ResetClub()
		return nil
	}
	return fmt.Errorf("unknown ClubMember edge %s", name)
}

// CompanyMutation represents an operation that mutates the Company nodes in the graph.
type CompanyMutation struct {
	config
	op              Op
	typ             string
	id              *int
	name            *string
	business_number *string
	address         *string
	description     *string
	profile_image   *string
	hompage         *string
	clearedFields   map[string]struct{}
	user            *int
	cleareduser     bool
	done            bool
	oldValue        func(context.Context) (*Company, error)
	predicates      []predicate.Company
}

var _ ent.Mutation = (*CompanyMutation)(nil)

// companyOption allows management of the mutation configuration using functional options.
type companyOption func(*CompanyMutation)

// newCompanyMutation creates new mutation for the Company entity.
func newCompanyMutation(c config, op Op, opts ...companyOption) *CompanyMutation {
	m := &CompanyMutation{
		config:        c,
		op:            op,
		typ:           TypeCompany,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withCompanyID sets the ID field of the mutation.
func withCompanyID(id int) companyOption {
	return func(m *CompanyMutation) {
		var (
			err   error
			once  sync.Once
			value *Company
		)
		m.oldValue = func(ctx context.Context) (*Company, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Company.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withCompany sets the old Company of the mutation.
func withCompany(node *Company) companyOption {
	return func(m *CompanyMutation) {
		m.oldValue = func(context.Context) (*Company, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m CompanyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m CompanyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Company entities.
func (m *CompanyMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *CompanyMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *CompanyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *CompanyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *CompanyMutation) ResetName() {
	m.name = nil
}

// SetBusinessNumber sets the "business_number" field.
func (m *CompanyMutation) SetBusinessNumber(s string) {
	m.business_number = &s
}

// BusinessNumber returns the value of the "business_number" field in the mutation.
func (m *CompanyMutation) BusinessNumber() (r string, exists bool) {
	v := m.business_number
	if v == nil {
		return
	}
	return *v, true
}

// OldBusinessNumber returns the old "business_number" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldBusinessNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBusinessNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBusinessNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBusinessNumber: %w", err)
	}
	return oldValue.BusinessNumber, nil
}

// ResetBusinessNumber resets all changes to the "business_number" field.
func (m *CompanyMutation) ResetBusinessNumber() {
	m.business_number = nil
}

// SetAddress sets the "address" field.
func (m *CompanyMutation) SetAddress(s string) {
	m.address = &s
}

// Address returns the value of the "address" field in the mutation.
func (m *CompanyMutation) Address() (r string, exists bool) {
	v := m.address
	if v == nil {
		return
	}
	return *v, true
}

// OldAddress returns the old "address" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldAddress(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldAddress is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldAddress requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAddress: %w", err)
	}
	return oldValue.Address, nil
}

// ClearAddress clears the value of the "address" field.
func (m *CompanyMutation) ClearAddress() {
	m.address = nil
	m.clearedFields[company.FieldAddress] = struct{}{}
}

// AddressCleared returns if the "address" field was cleared in this mutation.
func (m *CompanyMutation) AddressCleared() bool {
	_, ok := m.clearedFields[company.FieldAddress]
	return ok
}

// ResetAddress resets all changes to the "address" field.
func (m *CompanyMutation) ResetAddress() {
	m.address = nil
	delete(m.clearedFields, company.FieldAddress)
}

// SetDescription sets the "description" field.
func (m *CompanyMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *CompanyMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldDescription(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *CompanyMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[company.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *CompanyMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[company.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *CompanyMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, company.FieldDescription)
}

// SetProfileImage sets the "profile_image" field.
func (m *CompanyMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *CompanyMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *CompanyMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[company.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *CompanyMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[company.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *CompanyMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, company.FieldProfileImage)
}

// SetHompage sets the "hompage" field.
func (m *CompanyMutation) SetHompage(s string) {
	m.hompage = &s
}

// Hompage returns the value of the "hompage" field in the mutation.
func (m *CompanyMutation) Hompage() (r string, exists bool) {
	v := m.hompage
	if v == nil {
		return
	}
	return *v, true
}

// OldHompage returns the old "hompage" field's value of the Company entity.
// If the Company object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *CompanyMutation) OldHompage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHompage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHompage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHompage: %w", err)
	}
	return oldValue.Hompage, nil
}

// ClearHompage clears the value of the "hompage" field.
func (m *CompanyMutation) ClearHompage() {
	m.hompage = nil
	m.clearedFields[company.FieldHompage] = struct{}{}
}

// HompageCleared returns if the "hompage" field was cleared in this mutation.
func (m *CompanyMutation) HompageCleared() bool {
	_, ok := m.clearedFields[company.FieldHompage]
	return ok
}

// ResetHompage resets all changes to the "hompage" field.
func (m *CompanyMutation) ResetHompage() {
	m.hompage = nil
	delete(m.clearedFields, company.FieldHompage)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *CompanyMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *CompanyMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *CompanyMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *CompanyMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *CompanyMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *CompanyMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the CompanyMutation builder.
func (m *CompanyMutation) Where(ps ...predicate.Company) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *CompanyMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Company).
func (m *CompanyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *CompanyMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.name != nil {
		fields = append(fields, company.FieldName)
	}
	if m.business_number != nil {
		fields = append(fields, company.FieldBusinessNumber)
	}
	if m.address != nil {
		fields = append(fields, company.FieldAddress)
	}
	if m.description != nil {
		fields = append(fields, company.FieldDescription)
	}
	if m.profile_image != nil {
		fields = append(fields, company.FieldProfileImage)
	}
	if m.hompage != nil {
		fields = append(fields, company.FieldHompage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *CompanyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case company.FieldName:
		return m.Name()
	case company.FieldBusinessNumber:
		return m.BusinessNumber()
	case company.FieldAddress:
		return m.Address()
	case company.FieldDescription:
		return m.Description()
	case company.FieldProfileImage:
		return m.ProfileImage()
	case company.FieldHompage:
		return m.Hompage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *CompanyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case company.FieldName:
		return m.OldName(ctx)
	case company.FieldBusinessNumber:
		return m.OldBusinessNumber(ctx)
	case company.FieldAddress:
		return m.OldAddress(ctx)
	case company.FieldDescription:
		return m.OldDescription(ctx)
	case company.FieldProfileImage:
		return m.OldProfileImage(ctx)
	case company.FieldHompage:
		return m.OldHompage(ctx)
	}
	return nil, fmt.Errorf("unknown Company field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case company.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case company.FieldBusinessNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBusinessNumber(v)
		return nil
	case company.FieldAddress:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAddress(v)
		return nil
	case company.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case company.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	case company.FieldHompage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHompage(v)
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *CompanyMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *CompanyMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *CompanyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Company numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *CompanyMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(company.FieldAddress) {
		fields = append(fields, company.FieldAddress)
	}
	if m.FieldCleared(company.FieldDescription) {
		fields = append(fields, company.FieldDescription)
	}
	if m.FieldCleared(company.FieldProfileImage) {
		fields = append(fields, company.FieldProfileImage)
	}
	if m.FieldCleared(company.FieldHompage) {
		fields = append(fields, company.FieldHompage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *CompanyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *CompanyMutation) ClearField(name string) error {
	switch name {
	case company.FieldAddress:
		m.ClearAddress()
		return nil
	case company.FieldDescription:
		m.ClearDescription()
		return nil
	case company.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	case company.FieldHompage:
		m.ClearHompage()
		return nil
	}
	return fmt.Errorf("unknown Company nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *CompanyMutation) ResetField(name string) error {
	switch name {
	case company.FieldName:
		m.ResetName()
		return nil
	case company.FieldBusinessNumber:
		m.ResetBusinessNumber()
		return nil
	case company.FieldAddress:
		m.ResetAddress()
		return nil
	case company.FieldDescription:
		m.ResetDescription()
		return nil
	case company.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	case company.FieldHompage:
		m.ResetHompage()
		return nil
	}
	return fmt.Errorf("unknown Company field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *CompanyMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.user != nil {
		edges = append(edges, company.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *CompanyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case company.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *CompanyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *CompanyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *CompanyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.cleareduser {
		edges = append(edges, company.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *CompanyMutation) EdgeCleared(name string) bool {
	switch name {
	case company.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *CompanyMutation) ClearEdge(name string) error {
	switch name {
	case company.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Company unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *CompanyMutation) ResetEdge(name string) error {
	switch name {
	case company.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Company edge %s", name)
}

// StudentMutation represents an operation that mutates the Student nodes in the graph.
type StudentMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	name               *string
	university         *string
	profile_link       *string
	profile_image      *string
	clearedFields      map[string]struct{}
	user               *int
	cleareduser        bool
	club               map[int]struct{}
	removedclub        map[int]struct{}
	clearedclub        bool
	club_member        map[int]struct{}
	removedclub_member map[int]struct{}
	clearedclub_member bool
	done               bool
	oldValue           func(context.Context) (*Student, error)
	predicates         []predicate.Student
}

var _ ent.Mutation = (*StudentMutation)(nil)

// studentOption allows management of the mutation configuration using functional options.
type studentOption func(*StudentMutation)

// newStudentMutation creates new mutation for the Student entity.
func newStudentMutation(c config, op Op, opts ...studentOption) *StudentMutation {
	m := &StudentMutation{
		config:        c,
		op:            op,
		typ:           TypeStudent,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStudentID sets the ID field of the mutation.
func withStudentID(id int) studentOption {
	return func(m *StudentMutation) {
		var (
			err   error
			once  sync.Once
			value *Student
		)
		m.oldValue = func(ctx context.Context) (*Student, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Student.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStudent sets the old Student of the mutation.
func withStudent(node *Student) studentOption {
	return func(m *StudentMutation) {
		m.oldValue = func(context.Context) (*Student, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StudentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StudentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Student entities.
func (m *StudentMutation) SetID(id int) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StudentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the "name" field.
func (m *StudentMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *StudentMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *StudentMutation) ResetName() {
	m.name = nil
}

// SetUniversity sets the "university" field.
func (m *StudentMutation) SetUniversity(s string) {
	m.university = &s
}

// University returns the value of the "university" field in the mutation.
func (m *StudentMutation) University() (r string, exists bool) {
	v := m.university
	if v == nil {
		return
	}
	return *v, true
}

// OldUniversity returns the old "university" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldUniversity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldUniversity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldUniversity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUniversity: %w", err)
	}
	return oldValue.University, nil
}

// ResetUniversity resets all changes to the "university" field.
func (m *StudentMutation) ResetUniversity() {
	m.university = nil
}

// SetProfileLink sets the "profile_link" field.
func (m *StudentMutation) SetProfileLink(s string) {
	m.profile_link = &s
}

// ProfileLink returns the value of the "profile_link" field in the mutation.
func (m *StudentMutation) ProfileLink() (r string, exists bool) {
	v := m.profile_link
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileLink returns the old "profile_link" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldProfileLink(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileLink is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileLink requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileLink: %w", err)
	}
	return oldValue.ProfileLink, nil
}

// ClearProfileLink clears the value of the "profile_link" field.
func (m *StudentMutation) ClearProfileLink() {
	m.profile_link = nil
	m.clearedFields[student.FieldProfileLink] = struct{}{}
}

// ProfileLinkCleared returns if the "profile_link" field was cleared in this mutation.
func (m *StudentMutation) ProfileLinkCleared() bool {
	_, ok := m.clearedFields[student.FieldProfileLink]
	return ok
}

// ResetProfileLink resets all changes to the "profile_link" field.
func (m *StudentMutation) ResetProfileLink() {
	m.profile_link = nil
	delete(m.clearedFields, student.FieldProfileLink)
}

// SetProfileImage sets the "profile_image" field.
func (m *StudentMutation) SetProfileImage(s string) {
	m.profile_image = &s
}

// ProfileImage returns the value of the "profile_image" field in the mutation.
func (m *StudentMutation) ProfileImage() (r string, exists bool) {
	v := m.profile_image
	if v == nil {
		return
	}
	return *v, true
}

// OldProfileImage returns the old "profile_image" field's value of the Student entity.
// If the Student object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StudentMutation) OldProfileImage(ctx context.Context) (v *string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldProfileImage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldProfileImage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldProfileImage: %w", err)
	}
	return oldValue.ProfileImage, nil
}

// ClearProfileImage clears the value of the "profile_image" field.
func (m *StudentMutation) ClearProfileImage() {
	m.profile_image = nil
	m.clearedFields[student.FieldProfileImage] = struct{}{}
}

// ProfileImageCleared returns if the "profile_image" field was cleared in this mutation.
func (m *StudentMutation) ProfileImageCleared() bool {
	_, ok := m.clearedFields[student.FieldProfileImage]
	return ok
}

// ResetProfileImage resets all changes to the "profile_image" field.
func (m *StudentMutation) ResetProfileImage() {
	m.profile_image = nil
	delete(m.clearedFields, student.FieldProfileImage)
}

// SetUserID sets the "user" edge to the User entity by id.
func (m *StudentMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the "user" edge to the User entity.
func (m *StudentMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *StudentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the "user" edge ID in the mutation.
func (m *StudentMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *StudentMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *StudentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// AddClubIDs adds the "club" edge to the Club entity by ids.
func (m *StudentMutation) AddClubIDs(ids ...int) {
	if m.club == nil {
		m.club = make(map[int]struct{})
	}
	for i := range ids {
		m.club[ids[i]] = struct{}{}
	}
}

// ClearClub clears the "club" edge to the Club entity.
func (m *StudentMutation) ClearClub() {
	m.clearedclub = true
}

// ClubCleared reports if the "club" edge to the Club entity was cleared.
func (m *StudentMutation) ClubCleared() bool {
	return m.clearedclub
}

// RemoveClubIDs removes the "club" edge to the Club entity by IDs.
func (m *StudentMutation) RemoveClubIDs(ids ...int) {
	if m.removedclub == nil {
		m.removedclub = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club, ids[i])
		m.removedclub[ids[i]] = struct{}{}
	}
}

// RemovedClub returns the removed IDs of the "club" edge to the Club entity.
func (m *StudentMutation) RemovedClubIDs() (ids []int) {
	for id := range m.removedclub {
		ids = append(ids, id)
	}
	return
}

// ClubIDs returns the "club" edge IDs in the mutation.
func (m *StudentMutation) ClubIDs() (ids []int) {
	for id := range m.club {
		ids = append(ids, id)
	}
	return
}

// ResetClub resets all changes to the "club" edge.
func (m *StudentMutation) ResetClub() {
	m.club = nil
	m.clearedclub = false
	m.removedclub = nil
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *StudentMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *StudentMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *StudentMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *StudentMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *StudentMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *StudentMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *StudentMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// Where appends a list predicates to the StudentMutation builder.
func (m *StudentMutation) Where(ps ...predicate.Student) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *StudentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Student).
func (m *StudentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StudentMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.name != nil {
		fields = append(fields, student.FieldName)
	}
	if m.university != nil {
		fields = append(fields, student.FieldUniversity)
	}
	if m.profile_link != nil {
		fields = append(fields, student.FieldProfileLink)
	}
	if m.profile_image != nil {
		fields = append(fields, student.FieldProfileImage)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StudentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case student.FieldName:
		return m.Name()
	case student.FieldUniversity:
		return m.University()
	case student.FieldProfileLink:
		return m.ProfileLink()
	case student.FieldProfileImage:
		return m.ProfileImage()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StudentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case student.FieldName:
		return m.OldName(ctx)
	case student.FieldUniversity:
		return m.OldUniversity(ctx)
	case student.FieldProfileLink:
		return m.OldProfileLink(ctx)
	case student.FieldProfileImage:
		return m.OldProfileImage(ctx)
	}
	return nil, fmt.Errorf("unknown Student field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case student.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case student.FieldUniversity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUniversity(v)
		return nil
	case student.FieldProfileLink:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileLink(v)
		return nil
	case student.FieldProfileImage:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetProfileImage(v)
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StudentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StudentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StudentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Student numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StudentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(student.FieldProfileLink) {
		fields = append(fields, student.FieldProfileLink)
	}
	if m.FieldCleared(student.FieldProfileImage) {
		fields = append(fields, student.FieldProfileImage)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StudentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StudentMutation) ClearField(name string) error {
	switch name {
	case student.FieldProfileLink:
		m.ClearProfileLink()
		return nil
	case student.FieldProfileImage:
		m.ClearProfileImage()
		return nil
	}
	return fmt.Errorf("unknown Student nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StudentMutation) ResetField(name string) error {
	switch name {
	case student.FieldName:
		m.ResetName()
		return nil
	case student.FieldUniversity:
		m.ResetUniversity()
		return nil
	case student.FieldProfileLink:
		m.ResetProfileLink()
		return nil
	case student.FieldProfileImage:
		m.ResetProfileImage()
		return nil
	}
	return fmt.Errorf("unknown Student field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StudentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.user != nil {
		edges = append(edges, student.EdgeUser)
	}
	if m.club != nil {
		edges = append(edges, student.EdgeClub)
	}
	if m.club_member != nil {
		edges = append(edges, student.EdgeClubMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StudentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	case student.EdgeClub:
		ids := make([]ent.Value, 0, len(m.club))
		for id := range m.club {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StudentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedclub != nil {
		edges = append(edges, student.EdgeClub)
	}
	if m.removedclub_member != nil {
		edges = append(edges, student.EdgeClubMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StudentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case student.EdgeClub:
		ids := make([]ent.Value, 0, len(m.removedclub))
		for id := range m.removedclub {
			ids = append(ids, id)
		}
		return ids
	case student.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StudentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.cleareduser {
		edges = append(edges, student.EdgeUser)
	}
	if m.clearedclub {
		edges = append(edges, student.EdgeClub)
	}
	if m.clearedclub_member {
		edges = append(edges, student.EdgeClubMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StudentMutation) EdgeCleared(name string) bool {
	switch name {
	case student.EdgeUser:
		return m.cleareduser
	case student.EdgeClub:
		return m.clearedclub
	case student.EdgeClubMember:
		return m.clearedclub_member
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StudentMutation) ClearEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Student unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StudentMutation) ResetEdge(name string) error {
	switch name {
	case student.EdgeUser:
		m.ResetUser()
		return nil
	case student.EdgeClub:
		m.ResetClub()
		return nil
	case student.EdgeClubMember:
		m.ResetClubMember()
		return nil
	}
	return fmt.Errorf("unknown Student edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                 Op
	typ                string
	id                 *int
	email              *string
	password           *string
	kind               *user.Kind
	clearedFields      map[string]struct{}
	student            map[int]struct{}
	removedstudent     map[int]struct{}
	clearedstudent     bool
	company            map[int]struct{}
	removedcompany     map[int]struct{}
	clearedcompany     bool
	club_member        map[int]struct{}
	removedclub_member map[int]struct{}
	clearedclub_member bool
	done               bool
	oldValue           func(context.Context) (*User, error)
	predicates         []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the "password" field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the value of the "password" field in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old "password" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword resets all changes to the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetKind sets the "kind" field.
func (m *UserMutation) SetKind(u user.Kind) {
	m.kind = &u
}

// Kind returns the value of the "kind" field in the mutation.
func (m *UserMutation) Kind() (r user.Kind, exists bool) {
	v := m.kind
	if v == nil {
		return
	}
	return *v, true
}

// OldKind returns the old "kind" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldKind(ctx context.Context) (v user.Kind, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldKind is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldKind requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldKind: %w", err)
	}
	return oldValue.Kind, nil
}

// ResetKind resets all changes to the "kind" field.
func (m *UserMutation) ResetKind() {
	m.kind = nil
}

// AddStudentIDs adds the "student" edge to the Student entity by ids.
func (m *UserMutation) AddStudentIDs(ids ...int) {
	if m.student == nil {
		m.student = make(map[int]struct{})
	}
	for i := range ids {
		m.student[ids[i]] = struct{}{}
	}
}

// ClearStudent clears the "student" edge to the Student entity.
func (m *UserMutation) ClearStudent() {
	m.clearedstudent = true
}

// StudentCleared reports if the "student" edge to the Student entity was cleared.
func (m *UserMutation) StudentCleared() bool {
	return m.clearedstudent
}

// RemoveStudentIDs removes the "student" edge to the Student entity by IDs.
func (m *UserMutation) RemoveStudentIDs(ids ...int) {
	if m.removedstudent == nil {
		m.removedstudent = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.student, ids[i])
		m.removedstudent[ids[i]] = struct{}{}
	}
}

// RemovedStudent returns the removed IDs of the "student" edge to the Student entity.
func (m *UserMutation) RemovedStudentIDs() (ids []int) {
	for id := range m.removedstudent {
		ids = append(ids, id)
	}
	return
}

// StudentIDs returns the "student" edge IDs in the mutation.
func (m *UserMutation) StudentIDs() (ids []int) {
	for id := range m.student {
		ids = append(ids, id)
	}
	return
}

// ResetStudent resets all changes to the "student" edge.
func (m *UserMutation) ResetStudent() {
	m.student = nil
	m.clearedstudent = false
	m.removedstudent = nil
}

// AddCompanyIDs adds the "company" edge to the Company entity by ids.
func (m *UserMutation) AddCompanyIDs(ids ...int) {
	if m.company == nil {
		m.company = make(map[int]struct{})
	}
	for i := range ids {
		m.company[ids[i]] = struct{}{}
	}
}

// ClearCompany clears the "company" edge to the Company entity.
func (m *UserMutation) ClearCompany() {
	m.clearedcompany = true
}

// CompanyCleared reports if the "company" edge to the Company entity was cleared.
func (m *UserMutation) CompanyCleared() bool {
	return m.clearedcompany
}

// RemoveCompanyIDs removes the "company" edge to the Company entity by IDs.
func (m *UserMutation) RemoveCompanyIDs(ids ...int) {
	if m.removedcompany == nil {
		m.removedcompany = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.company, ids[i])
		m.removedcompany[ids[i]] = struct{}{}
	}
}

// RemovedCompany returns the removed IDs of the "company" edge to the Company entity.
func (m *UserMutation) RemovedCompanyIDs() (ids []int) {
	for id := range m.removedcompany {
		ids = append(ids, id)
	}
	return
}

// CompanyIDs returns the "company" edge IDs in the mutation.
func (m *UserMutation) CompanyIDs() (ids []int) {
	for id := range m.company {
		ids = append(ids, id)
	}
	return
}

// ResetCompany resets all changes to the "company" edge.
func (m *UserMutation) ResetCompany() {
	m.company = nil
	m.clearedcompany = false
	m.removedcompany = nil
}

// AddClubMemberIDs adds the "club_member" edge to the ClubMember entity by ids.
func (m *UserMutation) AddClubMemberIDs(ids ...int) {
	if m.club_member == nil {
		m.club_member = make(map[int]struct{})
	}
	for i := range ids {
		m.club_member[ids[i]] = struct{}{}
	}
}

// ClearClubMember clears the "club_member" edge to the ClubMember entity.
func (m *UserMutation) ClearClubMember() {
	m.clearedclub_member = true
}

// ClubMemberCleared reports if the "club_member" edge to the ClubMember entity was cleared.
func (m *UserMutation) ClubMemberCleared() bool {
	return m.clearedclub_member
}

// RemoveClubMemberIDs removes the "club_member" edge to the ClubMember entity by IDs.
func (m *UserMutation) RemoveClubMemberIDs(ids ...int) {
	if m.removedclub_member == nil {
		m.removedclub_member = make(map[int]struct{})
	}
	for i := range ids {
		delete(m.club_member, ids[i])
		m.removedclub_member[ids[i]] = struct{}{}
	}
}

// RemovedClubMember returns the removed IDs of the "club_member" edge to the ClubMember entity.
func (m *UserMutation) RemovedClubMemberIDs() (ids []int) {
	for id := range m.removedclub_member {
		ids = append(ids, id)
	}
	return
}

// ClubMemberIDs returns the "club_member" edge IDs in the mutation.
func (m *UserMutation) ClubMemberIDs() (ids []int) {
	for id := range m.club_member {
		ids = append(ids, id)
	}
	return
}

// ResetClubMember resets all changes to the "club_member" edge.
func (m *UserMutation) ResetClubMember() {
	m.club_member = nil
	m.clearedclub_member = false
	m.removedclub_member = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	if m.kind != nil {
		fields = append(fields, user.FieldKind)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	case user.FieldKind:
		return m.Kind()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	case user.FieldKind:
		return m.OldKind(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	case user.FieldKind:
		v, ok := value.(user.Kind)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetKind(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	case user.FieldKind:
		m.ResetKind()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.student != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.company != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.club_member != nil {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.student))
		for id := range m.student {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.company))
		for id := range m.company {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.club_member))
		for id := range m.club_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedstudent != nil {
		edges = append(edges, user.EdgeStudent)
	}
	if m.removedcompany != nil {
		edges = append(edges, user.EdgeCompany)
	}
	if m.removedclub_member != nil {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeStudent:
		ids := make([]ent.Value, 0, len(m.removedstudent))
		for id := range m.removedstudent {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeCompany:
		ids := make([]ent.Value, 0, len(m.removedcompany))
		for id := range m.removedcompany {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeClubMember:
		ids := make([]ent.Value, 0, len(m.removedclub_member))
		for id := range m.removedclub_member {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedstudent {
		edges = append(edges, user.EdgeStudent)
	}
	if m.clearedcompany {
		edges = append(edges, user.EdgeCompany)
	}
	if m.clearedclub_member {
		edges = append(edges, user.EdgeClubMember)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeStudent:
		return m.clearedstudent
	case user.EdgeCompany:
		return m.clearedcompany
	case user.EdgeClubMember:
		return m.clearedclub_member
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeStudent:
		m.ResetStudent()
		return nil
	case user.EdgeCompany:
		m.ResetCompany()
		return nil
	case user.EdgeClubMember:
		m.ResetClubMember()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
